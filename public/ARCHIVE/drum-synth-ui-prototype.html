<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Kessho Drum Synth — Complete UI</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { overflow-x: hidden; width: 100%; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      color: #e0e0e0;
      min-height: 100vh;
      padding: 12px;
    }
    .container { max-width: 1200px; margin: 0 auto; display: flex; gap: 12px; align-items: flex-start; flex-wrap: wrap; }
    .sound-panel { flex: 0 0 460px; min-width: 0; max-width: 100%; }
    .sequencer-panel { flex: 1; min-width: 380px; max-width: 100%; }
    @media (max-width: 900px) { .sound-panel, .sequencer-panel { flex: 1 1 100%; min-width: 0; max-width: 100%; } }
    h1 { text-align: center; font-size: 1.1rem; color: #a78bfa; margin-bottom: 2px; }
    .subtitle { text-align: center; color: #666; font-size: 0.7rem; margin-bottom: 10px; }

    /* ── Master Strip ── */
    .master-strip {
      display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
      background: rgba(255,255,255,0.05); border-radius: 8px;
      padding: 8px 12px; margin-bottom: 8px;
      border: 1px solid #2a3a5e;
    }
    .master-item { display: flex; align-items: center; gap: 4px; flex: 1; min-width: 120px; }
    .master-item label { font-size: 0.65rem; color: #888; white-space: nowrap; }
    .master-item input[type=range] { flex: 1; height: 4px; }
    .master-item .val { font-size: 0.65rem; color: #a78bfa; min-width: 28px; text-align: right; }

    /* ── Voice Tabs ── */
    .voice-tabs { display: flex; gap: 2px; margin-bottom: 0; }
    .voice-tab {
      flex: 1; padding: 8px 0; text-align: center;
      border: none; border-radius: 8px 8px 0 0; cursor: pointer;
      font-size: 0.7rem; font-weight: 600;
      background: rgba(255,255,255,0.05); color: #666;
      transition: all 0.15s;
      display: flex; flex-direction: column; align-items: center; gap: 1px;
    }
    .voice-tab .icon { font-size: 1rem; }
    .voice-tab.active { color: #fff; }
    .voice-tab:hover:not(.active) { background: rgba(255,255,255,0.08); }
    .voice-tab[data-voice="sub"].active    { background: #ef4444; }
    .voice-tab[data-voice="kick"].active   { background: #f97316; }
    .voice-tab[data-voice="click"].active  { background: #eab308; }
    .voice-tab[data-voice="beepHi"].active { background: #22c55e; }
    .voice-tab[data-voice="beepLo"].active { background: #06b6d4; }
    .voice-tab[data-voice="noise"].active  { background: #8b5cf6; }
    .voice-tab[data-voice="membrane"].active { background: #e11d48; }
    .voice-tab[data-voice="freeze"].active  { background: #0ea5e9; }

    /* ── Voice Panel ── */
    .voice-panel {
      background: rgba(22, 33, 62, 0.95);
      border: 1px solid #2a3a5e;
      border-top: none;
      border-radius: 0 0 10px 10px;
      padding: 10px;
      display: none;
    }
    .voice-panel.active { display: block; }

    /* ── Morph Row ── */
    .morph-row {
      display: flex; gap: 6px; align-items: center;
      margin-bottom: 8px; padding: 6px 8px;
      background: rgba(167,139,250,0.08); border-radius: 6px;
    }
    .morph-row select { flex: 1; font-size: 0.65rem; background: #1a1a2e; color: #ccc; border: 1px solid #444; border-radius: 4px; padding: 3px; max-width: 130px; }
    .morph-row input[type=range] { flex: 2; height: 4px; }
    .morph-row .morph-label { font-size: 0.6rem; color: #a78bfa; white-space: nowrap; }

    /* ── Param Sections ── */
    .param-section {
      margin-bottom: 6px;
    }
    .section-header {
      font-size: 0.65rem; color: #888; text-transform: uppercase; letter-spacing: 0.5px;
      margin-bottom: 3px; padding-bottom: 2px;
      border-bottom: 1px solid rgba(255,255,255,0.06);
      cursor: pointer; user-select: none;
      display: flex; justify-content: space-between; align-items: center;
    }
    .section-header::after { content: '▾'; font-size: 0.5rem; }
    .section-header.collapsed::after { content: '▸'; }
    .section-body { transition: all 0.2s; }
    .section-body.collapsed { display: none; }

    /* ── Param Row ── */
    .param-row {
      display: flex; align-items: center; gap: 4px; margin: 2px 0;
    }
    .param-row label { font-size: 0.65rem; color: #999; min-width: 80px; flex-shrink: 0; }
    .param-row input[type=range] { flex: 1; height: 3px; accent-color: #a78bfa; }
    .param-row .val { font-size: 0.65rem; color: #a78bfa; min-width: 36px; text-align: right; font-variant-numeric: tabular-nums; }
    .param-row select { flex: 1; font-size: 0.65rem; background: #1a1a2e; color: #ccc; border: 1px solid #444; border-radius: 4px; padding: 2px 4px; }

    /* ── Trigger Button ── */
    .trigger-row {
      display: flex; gap: 6px; margin-bottom: 8px;
    }
    .trigger-btn {
      flex: 1; padding: 8px; border: none; border-radius: 6px;
      font-size: 0.75rem; font-weight: 600; cursor: pointer;
      background: rgba(167,139,250,0.2); color: #a78bfa;
      transition: all 0.1s;
    }
    .trigger-btn:hover { background: rgba(167,139,250,0.35); }
    .trigger-btn:active { transform: scale(0.97); background: rgba(167,139,250,0.5); }
    .trigger-btn.random { background: rgba(239,68,68,0.2); color: #f87171; }
    .trigger-btn.random:hover { background: rgba(239,68,68,0.35); }
    .trigger-btn.random.active { background: rgba(239,68,68,0.5); }

    /* ── Delay Section ── */
    .delay-section {
      margin-top: 10px; padding: 8px;
      background: rgba(255,255,255,0.03); border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .delay-section .section-header { color: #f59e0b; }

    /* ── Envelope Visualizer ── */
    .env-visualizer-wrap {
      position: relative;
      margin-bottom: 8px;
    }
    .env-visualizer {
      width: 100%;
      height: 210px;
      background: rgba(0,0,0,0.35);
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.08);
      display: block;
    }
    .viz-mode-label {
      position: absolute; top: 2px; left: 6px;
      font-size: 0.5rem; color: rgba(255,255,255,0.3);
      pointer-events: none; letter-spacing: 0.5px; text-transform: uppercase;
    }

    /* ── Preset Count Badge ── */
    .preset-count { font-size: 0.55rem; color: #666; margin-left: 4px; }

    /* ── Status Bar ── */
    .status-bar {
      text-align: center; font-size: 0.6rem; color: #555; margin-top: 8px; padding: 4px;
    }
    .status-bar .count { color: #a78bfa; }

    /* ══ SEQUENCER PANEL STYLES ══ */
    .seq-title { color: #00d4ff; font-size: 1rem; margin-bottom: 8px; text-align: center; }
    .seq-transport {
      display: flex; gap: 8px; align-items: center;
      background: rgba(255,255,255,0.05); border-radius: 8px;
      padding: 8px 12px; margin-bottom: 8px;
    }
    .seq-play-btn {
      width: 40px; height: 40px; border-radius: 50%; border: none;
      font-size: 1.1rem; cursor: pointer; flex-shrink: 0;
      background: #22c55e; color: #000; font-weight: bold;
      transition: all 0.15s;
    }
    .seq-play-btn.playing { background: #ef4444; }
    .seq-play-btn:hover { transform: scale(1.05); }
    .seq-transport label { font-size: 0.65rem; color: #888; display: flex; flex-direction: column; gap: 2px; }
    .seq-transport input, .seq-transport select {
      background: #1a1a2e; color: #fff; border: 1px solid #333;
      border-radius: 4px; padding: 4px 6px; font-size: 0.75rem; width: 64px;
    }

    /* ── Tab Bar ── */
    .seq-tab-bar { display: flex; gap: 2px; margin-bottom: 0; }
    .seq-tab {
      flex: 1; padding: 6px 4px; text-align: center; border: none;
      border-radius: 6px 6px 0 0; cursor: pointer;
      font-size: 0.65rem; font-weight: 600;
      background: rgba(255,255,255,0.04); color: #555;
      transition: all 0.15s; user-select: none;
      display: flex; align-items: center; justify-content: center; gap: 4px;
    }
    .seq-tab.active { color: #fff; background: var(--sc); }
    .seq-tab:hover:not(.active) { background: rgba(255,255,255,0.08); }
    .seq-tab .seq-tab-ms {
      display: flex; gap: 2px; font-size: 0.5rem;
    }
    .seq-tab-ms button {
      border: none; border-radius: 2px; padding: 1px 4px; cursor: pointer;
      font-size: 0.5rem; font-weight: 700; background: rgba(0,0,0,0.3); color: #888;
      transition: all 0.1s;
    }
    .seq-tab-ms button.on { color: #fff; }
    .seq-tab-ms .mute-btn.on { background: #ef4444; }
    .seq-tab-ms .solo-btn.on { background: #eab308; color: #000; }

    /* ── Active sequencer body ── */
    .seq-body {
      background: rgba(22, 33, 62, 0.6); border: 1px solid rgba(255,255,255,0.06);
      border-top: none; border-radius: 0 0 8px 8px; padding: 8px; margin-bottom: 6px;
    }

    .seq-sources {
      display: flex; gap: 4px; align-items: center; flex-wrap: wrap;
      padding: 6px 8px; margin-bottom: 8px;
      background: rgba(255,255,255,0.03); border-radius: 6px;
    }
    .seq-sources-label { font-size: 0.6rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-right: 4px; }
    .seq-source-toggle {
      display: flex; align-items: center; gap: 3px;
      padding: 3px 8px; border-radius: 4px; cursor: pointer;
      font-size: 0.65rem; color: #888; background: rgba(255,255,255,0.04);
      transition: all 0.15s; user-select: none;
    }
    .seq-source-toggle input { display: none; }
    .seq-source-toggle.active { background: var(--vc); color: #000; font-weight: 600; }

    /* ── Per-seq controls row ── */
    .seq-per-controls {
      display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
      padding: 4px 8px; margin-bottom: 6px;
      background: rgba(255,255,255,0.02); border-radius: 4px;
    }
    .seq-per-controls label {
      font-size: 0.6rem; color: #888; display: flex; align-items: center; gap: 3px;
    }
    .seq-per-controls input, .seq-per-controls select {
      background: #1a1a2e; color: #fff; border: 1px solid #333;
      border-radius: 3px; padding: 2px 4px; font-size: 0.65rem; width: 52px;
    }
    .seq-link-btn, .seq-evolve-btn {
      padding: 2px 8px; font-size: 0.55rem; font-weight: 700; border: none;
      border-radius: 3px; cursor: pointer; background: rgba(255,255,255,0.08);
      color: #666; transition: all 0.15s; letter-spacing: 0.3px;
    }
    .seq-link-btn.on { background: var(--sc, #00d4ff); color: #000; }
    .seq-evolve-btn.on { background: #a855f7; color: #000; }
    .seq-evolve-panel {
      display: none; padding: 6px 8px; margin-bottom: 6px;
      background: rgba(168,85,247,0.06); border: 1px solid rgba(168,85,247,0.15);
      border-radius: 4px; font-size: 0.6rem;
    }
    .seq-evolve-panel.open { display: block; }
    .seq-evolve-panel label { color: #aaa; display: flex; align-items: center; gap: 3px; font-size: 0.58rem; }
    .seq-evolve-panel input[type=range] { width: 50px; height: 3px; accent-color: #a855f7; }
    .seq-evolve-panel input[type=number] { background: #1a1a2e; color: #fff; border: 1px solid #333; border-radius: 3px; padding: 2px 4px; font-size: 0.6rem; width: 36px; }
    .seq-evolve-row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-bottom: 3px; }
    .seq-evolve-checks { display: flex; gap: 6px; flex-wrap: wrap; }
    .seq-evolve-checks label { font-size: 0.55rem; color: #888; cursor: pointer; }
    .seq-evolve-checks input[type=checkbox] { accent-color: #a855f7; margin-right: 2px; }
    .seq-evolve-flash { animation: evolveFlash 0.4s ease-out; }
    @keyframes evolveFlash { 0% { box-shadow: inset 0 0 8px rgba(168,85,247,0.6); } 100% { box-shadow: none; } }
    .seq-lane-enable-btn {
      padding: 2px 8px; font-size: 0.55rem; font-weight: 400; border: none;
      border-radius: 3px; cursor: pointer; background: rgba(255,255,255,0.08);
      color: #666; transition: all 0.15s; letter-spacing: 0.3px;
    }
    .seq-lane-enable-btn.on { color: #000; }
    .seq-lane-trigger .seq-lane-enable-btn.on { background: #00d4ff; }
    .seq-lane-pitch .seq-lane-enable-btn.on { background: #ff6b81; }
    .seq-lane-expr .seq-lane-enable-btn.on { background: #ffa502; }
    .seq-lane-morph .seq-lane-enable-btn.on { background: #c084fc; }
    .seq-lane-dist .seq-lane-enable-btn.on { background: #2dd4bf; }

    .seq-lane {
      margin-bottom: 6px; border-radius: 6px; overflow: hidden;
      border: 1px solid rgba(255,255,255,0.06);
    }
    .seq-lane-header {
      display: flex; justify-content: space-between; align-items: center;
      padding: 6px 10px; cursor: pointer; user-select: none;
      background: rgba(255,255,255,0.04);
    }
    .seq-lane-title { font-size: 0.7rem; font-weight: 600; letter-spacing: 0.5px; }
    .seq-lane-trigger .seq-lane-title { color: var(--sc, #00d4ff); }
    .seq-lane-pitch .seq-lane-title { color: #ff6b81; }
    .seq-lane-expr .seq-lane-title { color: #ffa502; }
    .seq-lane-morph .seq-lane-title { color: #c084fc; }
    .seq-lane-dist .seq-lane-title { color: #2dd4bf; }
    /* ── Bipolar distance bars ── */
    .seq-dist-bar-wrap {
      width: 100%; height: 48px; background: #0f0f23; border-radius: 3px;
      border: 1px solid #333; position: relative; cursor: pointer;
      touch-action: none;
    }
    .seq-dist-bar-wrap.inactive { opacity: 0.25; pointer-events: none; }
    .seq-dist-bar-wrap .dist-center {
      position: absolute; left: 0; right: 0; top: 50%;
      height: 1px; background: #555; pointer-events: none;
    }
    .seq-dist-bar-wrap .dist-bar {
      position: absolute; left: 15%; right: 15%;
      background: #2dd4bf; border-radius: 2px;
      pointer-events: none; transition: top 0.05s, height 0.05s;
    }
    .seq-dist-bar-wrap .dist-val {
      position: absolute; left: 0; right: 0;
      text-align: center; font-size: 0.5rem; color: #ccc;
      pointer-events: none; z-index: 1;
    }
    .seq-dist-bar-wrap .dist-label-max {
      position: absolute; right: 2px; top: 1px;
      font-size: 0.4rem; color: #2dd4bf; pointer-events: none; opacity: 0.5;
    }
    .seq-dist-bar-wrap .dist-label-min {
      position: absolute; right: 2px; bottom: 1px;
      font-size: 0.4rem; color: #2dd4bf; pointer-events: none; opacity: 0.5;
    }
    /* ── Bipolar morph bars ── */
    .seq-morph-bar-wrap {
      width: 100%; height: 48px; background: #0f0f23; border-radius: 3px;
      border: 1px solid #333; position: relative; cursor: pointer;
      touch-action: none;
    }
    .seq-morph-bar-wrap.inactive { opacity: 0.25; pointer-events: none; }
    .seq-morph-bar-wrap .morph-center {
      position: absolute; left: 0; right: 0; top: 50%;
      height: 1px; background: #555; pointer-events: none;
    }
    .seq-morph-bar-wrap .morph-bar {
      position: absolute; left: 15%; right: 15%;
      background: #c084fc; border-radius: 2px;
      pointer-events: none; transition: top 0.05s, height 0.05s;
    }
    .seq-morph-bar-wrap .morph-val {
      position: absolute; left: 0; right: 0;
      text-align: center; font-size: 0.5rem; color: #ccc;
      pointer-events: none; z-index: 1;
    }
    .seq-morph-bar-wrap .morph-label-a {
      position: absolute; right: 2px; top: 1px;
      font-size: 0.4rem; color: #c084fc; pointer-events: none; opacity: 0.5;
    }
    .seq-morph-bar-wrap .morph-label-b {
      position: absolute; right: 2px; bottom: 1px;
      font-size: 0.4rem; color: #c084fc; pointer-events: none; opacity: 0.5;
    }
    .seq-lane-controls { display: flex; gap: 8px; align-items: center; }
    .seq-lane-controls label {
      font-size: 0.6rem; color: #888; display: flex; align-items: center; gap: 3px;
    }
    .seq-lane-controls input[type=number] {
      width: 36px; background: #1a1a2e; color: #fff; border: 1px solid #333;
      border-radius: 3px; padding: 2px 4px; font-size: 0.65rem; text-align: center;
    }
    .seq-lane-controls button {
      width: 20px; height: 20px; border: none; border-radius: 3px;
      background: rgba(255,255,255,0.1); color: #fff; font-size: 0.7rem;
      cursor: pointer; padding: 0; line-height: 20px;
    }
    .seq-lane-controls button:hover { background: rgba(255,255,255,0.2); }
    .seq-lane-expand { font-size: 0.6rem; color: #666; margin-left: 4px; }
    .seq-lane-body { padding: 8px 10px; background: rgba(0,0,0,0.15); }
    .seq-step-grid {
      display: grid; grid-template-columns: repeat(16, 1fr); gap: 3px; margin: 6px 0;
    }
    @media (max-width: 820px) {
      .seq-step-grid { grid-template-columns: repeat(8, 1fr); }
    }
    .seq-step { display: flex; flex-direction: column; align-items: center; gap: 2px; }
    .seq-step-num {
      font-size: 0.55rem;
      color: #555;
      height: 10px;
      line-height: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .seq-step-cell {
      width: 100%; aspect-ratio: 1; border-radius: 4px; cursor: pointer;
      border: 2px solid #333; background: #0f0f23;
      transition: all 0.1s; position: relative; overflow: hidden;
    }
    .seq-step-cell.active { background: transparent; border-color: var(--sc, #00d4ff); }
    .seq-step-cell.playing { box-shadow: 0 0 12px var(--sc, #00d4ff); transform: scale(1.08); }
    .seq-step-cell.inactive { opacity: 0.25; pointer-events: none; }

    /* ── Step cell integrated probability fill ── */
    .seq-step-cell .prob-fill {
      position: absolute; bottom: 0; left: 0; right: 0;
      background: var(--sc, #00d4ff); opacity: 0.3;
      pointer-events: none; transition: height 0.05s;
    }
    .seq-step-cell.active .prob-fill { opacity: 0.85; }
    .seq-step-cell .prob-label {
      position: absolute; top: 1px; left: 0; right: 0;
      text-align: center; font-size: 0.4rem; color: rgba(255,255,255,0.6);
      pointer-events: none; z-index: 1;
    }

    /* ── Drag value popup ── */
    .seq-drag-popup {
      position: fixed; pointer-events: none; z-index: 9999;
      background: rgba(0,0,0,0.85); color: #fff; font-size: 0.75rem;
      font-weight: 700; padding: 4px 8px; border-radius: 4px;
      border: 1px solid var(--sc, #00d4ff);
      transform: translate(-50%, calc(-100% - 48px)); white-space: nowrap;
      text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }

    .seq-step-ratchet {
      width: 100%; height: 14px; cursor: pointer; display: flex;
      align-items: center; justify-content: center; gap: 1px;
      -webkit-tap-highlight-color: transparent; touch-action: manipulation;
    }
    .seq-step-ratchet .ratch-line {
      width: 60%; height: 2px; background: #555; border-radius: 1px;
      flex-shrink: 0;
    }
    .seq-step-ratchet.multi .ratch-line { background: #c084fc; height: 2px; }
    .seq-step-ratchet.r2 { gap: 2px; }
    .seq-step-ratchet.r2 .ratch-line { width: 40%; }
    .seq-step-ratchet.r3 .ratch-line { width: 28%; }
    .seq-step-ratchet.r4 .ratch-line { width: 20%; }
    .seq-presets { display: flex; gap: 3px; flex-wrap: wrap; margin-bottom: 6px; }
    .seq-preset-btn {
      padding: 2px 6px; font-size: 0.55rem; border: none; border-radius: 3px;
      background: rgba(255,255,255,0.08); color: #888; cursor: pointer;
      transition: all 0.1s;
    }
    .seq-preset-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
    .seq-preset-btn.active { background: var(--sc, #00d4ff); color: #000; }
    .seq-offset-presets { display: flex; gap: 3px; flex-wrap: wrap; margin-bottom: 6px; }
    .seq-offset-btn {
      padding: 2px 6px; font-size: 0.55rem; border: none; border-radius: 3px;
      background: rgba(255,255,255,0.08); color: #888; cursor: pointer;
    }
    .seq-offset-btn:hover { background: rgba(255,255,255,0.15); color: #fff; }
    .seq-pitch-input {
      width: 100%; background: #0f0f23; border: 1px solid #444; border-radius: 3px;
      color: #ff6b81; font-size: 0.65rem; text-align: center; padding: 2px;
    }
    .seq-pitch-input:disabled { opacity: 0.25; }
    /* ── Bipolar pitch bars ── */
    .seq-pitch-bar-wrap {
      width: 100%; height: 48px; background: #0f0f23; border-radius: 3px;
      border: 1px solid #333; position: relative; cursor: pointer;
      touch-action: none;
    }
    .seq-pitch-bar-wrap.inactive { opacity: 0.25; pointer-events: none; }
    .seq-pitch-bar-wrap .pitch-center {
      position: absolute; left: 0; right: 0; top: 50%;
      height: 1px; background: #444; pointer-events: none;
    }
    .seq-pitch-bar-wrap .pitch-bar {
      position: absolute; left: 15%; right: 15%;
      background: #ff6b81; border-radius: 2px;
      pointer-events: none; transition: top 0.05s, height 0.05s;
    }
    .seq-pitch-bar-wrap .pitch-val {
      position: absolute; left: 0; right: 0;
      text-align: center; font-size: 0.5rem; color: #ccc;
      pointer-events: none; z-index: 1;
    }
    /* ── Tonal note name display ── */
    .seq-pitch-note-name {
      font-size: 0.45rem; color: #ff6b81; text-align: center;
      pointer-events: none; margin-top: 1px; min-height: 10px;
    }
    .seq-vel-bar-wrap {
      width: 100%; height: 40px; background: #0f0f23; border-radius: 3px;
      border: 1px solid #333; position: relative; cursor: pointer;
      display: flex; align-items: flex-end; touch-action: none;
    }
    .seq-vel-bar-wrap.inactive { opacity: 0.25; pointer-events: none; }
    .seq-vel-bar {
      width: 100%; background: #ffa502; border-radius: 0 0 2px 2px;
      transition: height 0.05s;
    }
    .seq-vel-label {
      position: absolute; top: 1px; left: 0; right: 0;
      text-align: center; font-size: 0.5rem; color: #888;
    }
    .seq-poly-info {
      text-align: center; font-size: 0.6rem; color: #555; padding: 4px; margin-top: 4px;
    }
    .seq-poly-info .hl { color: #ffa502; font-weight: 600; }

    /* ── Mini Overview Strip ── */
    .seq-mini-overview {
      display: flex; gap: 4px; padding: 6px 8px;
      background: rgba(0,0,0,0.2); border-radius: 6px; margin-top: 4px;
      flex-wrap: wrap;
    }
    @media (max-width: 600px) {
      .seq-mini-overview { display: grid; grid-template-columns: 1fr 1fr; }
    }
    .seq-mini-row {
      flex: 1; cursor: pointer; padding: 4px 6px; border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.06);
      transition: all 0.15s; position: relative;
    }
    .seq-mini-row.active { border-color: var(--sc); }
    .seq-mini-row.muted { opacity: 0.3; }
    .seq-mini-label {
      font-size: 0.5rem; font-weight: 700; color: var(--sc);
      margin-bottom: 2px; display: flex; justify-content: space-between; align-items: center;
    }
    .seq-mini-label .mini-ms { font-size: 0.45rem; color: #888; }
    .seq-mini-label .mini-ms .on { font-weight: 900; }
    .seq-mini-dots {
      display: flex; gap: 1px; font-size: 0.5rem; line-height: 1;
    }
    .seq-mini-dots .dot-hit { color: var(--sc); }
    .seq-mini-dots .dot-rest { color: #333; }
    .seq-mini-dots .dot-cur { background: var(--sc); color: #000; border-radius: 2px; padding: 0 1px; }

    /* ── View Toggle ── */
    .seq-view-toggle {
      display: flex; gap: 0; border-radius: 6px; overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12); width: fit-content;
    }
    .seq-view-btn {
      padding: 4px 14px; font-size: 0.6rem; font-weight: 700;
      border: none; cursor: pointer; background: rgba(255,255,255,0.04); color: #777;
      transition: all 0.15s; letter-spacing: 0.5px; text-transform: uppercase;
    }
    .seq-view-btn.active { background: #00d4ff; color: #000; }
    .seq-view-btn:hover:not(.active) { background: rgba(255,255,255,0.08); }

    /* ── Overview Mode ── */
    .seq-overview {
      display: flex; flex-direction: column; gap: 6px;
    }
    .seq-ov-row {
      border-radius: 6px; overflow: hidden;
      border: 1px solid rgba(255,255,255,0.06);
      transition: border-color 0.15s;
    }
    .seq-ov-row.ov-muted { opacity: 0.35; }
    .seq-ov-header {
      display: flex; align-items: center; gap: 6px; padding: 5px 8px;
      background: rgba(255,255,255,0.04); cursor: pointer; user-select: none;
      flex-wrap: wrap;
    }
    .seq-ov-name {
      font-size: 0.65rem; font-weight: 700; color: var(--sc);
      min-width: 32px;
    }
    .seq-ov-src {
      font-size: 0.5rem; color: #888;
    }
    .seq-ov-controls {
      display: flex; gap: 6px; align-items: center; margin-left: auto;
    }
    .seq-ov-controls label {
      font-size: 0.55rem; color: #888; display: flex; align-items: center; gap: 2px;
    }
    .seq-ov-controls input[type=number] {
      width: 32px; background: #1a1a2e; color: #fff; border: 1px solid #333;
      border-radius: 3px; padding: 1px 3px; font-size: 0.6rem; text-align: center;
    }
    .seq-ov-controls select {
      background: #1a1a2e; color: #fff; border: 1px solid #333;
      border-radius: 3px; padding: 1px 3px; font-size: 0.6rem; width: 48px;
    }
    .seq-ov-controls button {
      border: none; border-radius: 3px; padding: 1px 5px; cursor: pointer;
      font-size: 0.5rem; font-weight: 700; background: rgba(0,0,0,0.3); color: #888;
      transition: all 0.1s;
    }
    .seq-ov-controls button.on { color: #fff; }
    .seq-ov-controls .ov-mute-btn.on { background: #ef4444; }
    .seq-ov-controls .ov-solo-btn.on { background: #eab308; color: #000; }
    .seq-ov-grid-wrap {
      padding: 4px 8px 6px; background: rgba(0,0,0,0.15);
    }
    .seq-ov-grid-wrap .seq-step-grid {
      margin: 2px 0;
    }
    .seq-ov-grid-wrap .seq-step-cell {
      aspect-ratio: 1.4;
    }

    /* ══════════════════════════════════════════════════════════════════
       TOUCH-FRIENDLY OVERRIDES
       Minimum 44px touch targets (Apple HIG), larger fonts, adequate spacing.
       All rules below override earlier compact defaults.
       ══════════════════════════════════════════════════════════════════ */

    /* ── Global: eliminate 300ms tap delay, suppress tap highlight ── */
    button, select, input, label[style*="cursor"], .seq-tab, .voice-tab,
    .seq-source-toggle, .seq-mini-row, .section-header, .seq-step-cell,
    .seq-step-ratchet, .seq-preset-btn, .seq-offset-btn, .seq-view-btn,
    .seq-link-btn, .seq-evolve-btn, .seq-lane-enable-btn, .trigger-btn,
    .seq-ov-header, .seq-lane-header {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    /* ── Active-state feedback for touch (mirrors :hover) ── */
    .voice-tab:active:not(.active) { background: rgba(255,255,255,0.12); }
    .seq-tab:active:not(.active) { background: rgba(255,255,255,0.12); }
    .seq-preset-btn:active { background: rgba(255,255,255,0.2); color: #fff; }
    .seq-offset-btn:active { background: rgba(255,255,255,0.2); color: #fff; }
    .seq-view-btn:active:not(.active) { background: rgba(255,255,255,0.12); }
    .seq-lane-controls button:active { background: rgba(255,255,255,0.3); }
    .seq-mini-row:active { background: rgba(255,255,255,0.08); }
    .section-header:active { background: rgba(255,255,255,0.06); }
    .seq-link-btn:active, .seq-evolve-btn:active { background: rgba(255,255,255,0.2); }
    .seq-lane-enable-btn:active { background: rgba(255,255,255,0.2); }
    .seq-source-toggle:active { background: rgba(255,255,255,0.12); }
    .trigger-btn:active { transform: scale(0.97); background: rgba(167,139,250,0.5); }

    /* ── Master strip ── */
    .master-item label { font-size: 0.75rem; }
    .master-item input[type=range] { height: 24px; }
    .master-item .val { font-size: 0.75rem; }

    /* ── Voice tabs: 44px min-height ── */
    .voice-tabs { gap: 4px; }
    .voice-tab {
      padding: 10px 2px; min-height: 44px; font-size: 0.75rem;
    }
    .voice-tab .icon { font-size: 1.1rem; }

    /* ── Section headers: 44px ── */
    .section-header {
      min-height: 44px; padding: 10px 8px; font-size: 0.75rem;
      display: flex; align-items: center;
    }
    .section-header::after { font-size: 0.65rem; }

    /* ── Param rows: comfortable touch targets ── */
    .param-row { gap: 6px; margin: 4px 0; min-height: 36px; align-items: center; }
    .param-row label { font-size: 0.75rem; }
    .param-row input[type=range] { height: 24px; }
    .param-row .val { font-size: 0.75rem; }
    .param-row select { font-size: 0.75rem; padding: 6px 8px; min-height: 36px; }

    /* ── Morph row ── */
    .morph-row { padding: 8px 10px; gap: 8px; }
    .morph-row select { font-size: 0.75rem; padding: 6px; min-height: 36px; }
    .morph-row input[type=range] { height: 24px; }
    .morph-row .morph-label { font-size: 0.7rem; }

    /* ── Trigger button ── */
    .trigger-btn { padding: 12px; font-size: 0.85rem; min-height: 44px; }

    /* ── Play / Stop ── */
    .seq-play-btn { width: 48px; height: 48px; font-size: 1.2rem; }

    /* ── Transport controls ── */
    .seq-transport { padding: 10px 14px; gap: 10px; }
    .seq-transport label { font-size: 0.75rem; }
    .seq-transport input, .seq-transport select {
      font-size: 0.85rem; padding: 6px 8px; min-height: 36px;
    }

    /* ── Seq tab bar ── */
    .seq-tab-bar { gap: 4px; }
    .seq-tab {
      padding: 10px 6px; min-height: 44px; font-size: 0.75rem;
    }

    /* ── Mute / Solo buttons in tab bar ── */
    .seq-tab .seq-tab-ms { gap: 4px; }
    .seq-tab-ms button {
      padding: 4px 8px; font-size: 0.65rem; border-radius: 4px;
      min-height: 28px; min-width: 28px;
    }

    /* ── Source toggle chips ── */
    .seq-sources { gap: 6px; padding: 8px 10px; }
    .seq-source-toggle {
      padding: 8px 12px; font-size: 0.75rem; min-height: 40px;
      border-radius: 6px; gap: 5px;
    }

    /* ── Per-seq controls ── */
    .seq-per-controls { padding: 8px 10px; gap: 10px; }
    .seq-per-controls label { font-size: 0.7rem; gap: 4px; }
    .seq-per-controls input, .seq-per-controls select {
      font-size: 0.75rem; padding: 6px 8px; width: 60px; min-height: 36px;
    }

    /* ── Link / Evolve buttons ── */
    .seq-link-btn, .seq-evolve-btn {
      padding: 8px 14px; font-size: 0.7rem; min-height: 40px;
      border-radius: 6px; display: inline-flex; align-items: center;
    }

    /* ── Lane enable buttons ── */
    .seq-lane-enable-btn {
      padding: 6px 12px; font-size: 0.7rem; min-height: 36px; border-radius: 4px;
    }

    /* ── Evolve panel ── */
    .seq-evolve-panel { padding: 10px 12px; }
    .seq-evolve-panel label { font-size: 0.7rem; gap: 6px; }
    .seq-evolve-panel input[type=range] { width: 70px; height: 24px; }
    .seq-evolve-panel input[type=number] {
      font-size: 0.75rem; padding: 6px 8px; width: 48px; min-height: 36px;
    }
    .seq-evolve-row { gap: 12px; margin-bottom: 6px; }
    .seq-evolve-checks { gap: 10px 14px; }
    .seq-evolve-checks label {
      font-size: 0.7rem; padding: 6px 2px; min-height: 36px;
      display: inline-flex; align-items: center; gap: 4px;
    }
    .seq-evolve-checks input[type=checkbox] {
      width: 20px; height: 20px; margin-right: 4px;
    }

    /* ── Lane header ── */
    .seq-lane-header { padding: 10px 12px; min-height: 44px; }
    .seq-lane-title { font-size: 0.8rem; }

    /* ── Lane controls (Steps/Hits/Rotate) ── */
    .seq-lane-controls { gap: 10px; flex-wrap: wrap; }
    .seq-lane-controls label { font-size: 0.7rem; gap: 4px; }
    .seq-lane-controls input[type=number] {
      width: 44px; font-size: 0.8rem; padding: 4px 6px; min-height: 36px;
    }
    .seq-lane-controls button {
      width: 36px; height: 36px; font-size: 0.9rem;
      line-height: 36px; border-radius: 6px;
    }
    .seq-lane-controls select { min-height: 36px; font-size: 0.75rem; padding: 4px 6px; }

    /* ── Step grid: ensure adequate cell size ── */
    .seq-step-grid { gap: 4px; }
    .seq-step-num { font-size: 0.65rem; height: 14px; line-height: 14px; }
    .seq-step-cell {
      min-width: 28px; min-height: 28px; border-radius: 6px;
    }
    .seq-step-cell .prob-label { font-size: 0.5rem; }

    /* ── Ratchet row: taller touch target ── */
    .seq-step-ratchet { height: 28px; }

    /* ── Presets ── */
    .seq-presets { gap: 6px; }
    .seq-preset-btn {
      padding: 8px 12px; font-size: 0.7rem; min-height: 36px; border-radius: 6px;
    }
    .seq-offset-presets { gap: 6px; }
    .seq-offset-btn {
      padding: 8px 12px; font-size: 0.7rem; min-height: 36px; border-radius: 6px;
    }

    /* ── Morph bar labels ── */
    .seq-morph-bar-wrap .morph-label-a,
    .seq-morph-bar-wrap .morph-label-b { font-size: 0.55rem; }
    .seq-morph-bar-wrap .morph-val { font-size: 0.6rem; }

    /* ── Pitch / vel / expression bar labels ── */
    .seq-pitch-bar-wrap .pitch-val { font-size: 0.6rem; }
    .seq-pitch-note-name { font-size: 0.55rem; }
    .seq-vel-label { font-size: 0.6rem; }

    /* ── Mini overview strip ── */
    .seq-mini-overview { gap: 6px; padding: 8px 10px; }
    .seq-mini-row {
      padding: 10px 8px; min-height: 44px; border-radius: 6px;
    }
    .seq-mini-label { font-size: 0.6rem; }
    .seq-mini-label .mini-ms { font-size: 0.55rem; }
    .seq-mini-dots { gap: 2px; font-size: 0.6rem; }

    /* ── View toggle ── */
    .seq-view-toggle { border-radius: 8px; }
    .seq-view-btn {
      padding: 10px 18px; font-size: 0.7rem; min-height: 40px;
    }

    /* ── Overview mode ── */
    .seq-ov-header { padding: 10px 12px; min-height: 44px; }
    .seq-ov-name { font-size: 0.8rem; }
    .seq-ov-src { font-size: 0.65rem; }
    .seq-ov-controls { gap: 8px; flex-wrap: wrap; }
    .seq-ov-controls label { font-size: 0.7rem; gap: 4px; }
    .seq-ov-controls input[type=number] {
      width: 40px; font-size: 0.75rem; padding: 4px 6px; min-height: 32px;
    }
    .seq-ov-controls select {
      font-size: 0.75rem; padding: 4px 6px; min-height: 32px; width: 56px;
    }
    .seq-ov-controls button {
      padding: 6px 10px; font-size: 0.65rem; min-height: 32px; border-radius: 4px;
    }
    .seq-ov-grid-wrap { padding: 6px 10px 8px; }
    .seq-ov-grid-wrap .seq-step-cell { min-width: 24px; min-height: 24px; }

    /* ── Drag-number widget: replaces number inputs for touch ── */
    .seq-drag-num {
      display: inline-flex; align-items: center; justify-content: center;
      min-width: 44px; min-height: 40px; padding: 6px 10px;
      background: #1a1a2e; color: #fff; border: 1px solid #444;
      border-radius: 8px; font-size: 0.9rem; font-weight: 700;
      cursor: ns-resize; user-select: none; touch-action: none;
      -webkit-tap-highlight-color: transparent;
      font-variant-numeric: tabular-nums;
      transition: border-color 0.15s, background 0.15s;
    }
    .seq-drag-num:active, .seq-drag-num.dragging {
      border-color: var(--sc, #00d4ff); background: rgba(0,212,255,0.1);
    }
    .seq-drag-num-label {
      font-size: 0.7rem; color: #888; margin-right: 4px; pointer-events: none;
    }

    /* ── Range sliders: fatter thumb on touch devices ── */
    @media (pointer: coarse) {
      input[type=range] { height: 28px; }
      input[type=range]::-webkit-slider-thumb {
        width: 24px; height: 24px; border-radius: 50%;
      }
      input[type=range]::-moz-range-thumb {
        width: 24px; height: 24px; border-radius: 50%;
      }
    }

    /* ── Responsive: 4-column step grid on very narrow ── */
    @media (max-width: 400px) {
      .seq-step-grid { grid-template-columns: repeat(4, 1fr); }
      .seq-mini-overview { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<div class="container">
  <div class="sound-panel">
  <h1>Kessho Drum Synth</h1>
  <p class="subtitle">8-voice synthesis engine — all parameters</p>

  <!-- Master Strip -->
  <div class="master-strip">
    <div class="master-item">
      <label>Level</label>
      <input type="range" min="0" max="1" step="0.01" value="0.7" id="masterLevel">
      <span class="val" id="masterLevelVal">70%</span>
    </div>
    <div class="master-item">
      <label>Reverb</label>
      <input type="range" min="0" max="1" step="0.01" value="0.06" id="masterReverb">
      <span class="val" id="masterReverbVal">6%</span>
    </div>
  </div>

  <!-- Voice Tabs -->
  <div class="voice-tabs" id="voiceTabs"></div>

  <!-- Voice Panels (generated by JS) -->
  <div id="voicePanels"></div>

  <!-- Delay Section -->
  <div class="delay-section">
    <div class="section-header" onclick="this.classList.toggle('collapsed');this.nextElementSibling.classList.toggle('collapsed')">Delay</div>
    <div class="section-body" id="delayBody"></div>
  </div>

  <div class="status-bar">
    <span class="count" id="presetCount">0</span> presets loaded across 8 voices
  </div>
  </div><!-- /sound-panel -->

  <!-- ══ SEQUENCER PANEL ══ -->
  <div class="sequencer-panel">
    <h2 class="seq-title">Super Sequencer</h2>

    <!-- Global Transport + View Toggle -->
    <div class="seq-transport">
      <button id="seqPlayBtn" class="seq-play-btn" onclick="seqTogglePlay()">▶</button>
      <label><span class="seq-drag-num-label">BPM</span><span class="seq-drag-num" id="seqBpm">120</span></label>
      <div class="seq-view-toggle" id="seqViewToggle" style="margin-left:auto">
        <button class="seq-view-btn active" data-view="detail" onclick="seqSetView('detail')">Detail</button>
        <button class="seq-view-btn" data-view="overview" onclick="seqSetView('overview')">Overview</button>
      </div>
    </div>

    <!-- Detail Mode -->
    <div id="seqDetailWrap">
      <!-- Sequencer Tabs -->
      <div class="seq-tab-bar" id="seqTabBar"></div>
      <!-- Active Sequencer Body (rendered by JS) -->
      <div class="seq-body" id="seqBody"></div>
      <!-- Mini Overview (all 4 sequencers) -->
      <div class="seq-mini-overview" id="seqMiniOverview"></div>
    </div>

    <!-- Overview Mode -->
    <div id="seqOverviewWrap" style="display:none">
      <div class="seq-overview" id="seqOverview"></div>
    </div>
  </div>
</div>

<script>
// ══════════════════════════════════════════════════════════════════
// VOICE DEFINITIONS — every synth param with display config
// ══════════════════════════════════════════════════════════════════

const VOICES = {
  sub: {
    label: 'Sub', icon: '◉\uFE0E', color: '#ef4444',
    sections: {
      'Tone': [
        { key: 'drumSubFreq', label: 'Frequency', min: 20, max: 100, step: 1, unit: 'Hz', def: 50 },
        { key: 'drumSubTone', label: 'Tone', min: 0, max: 1.5, step: 0.01, unit: '%', def: 0.1 },
        { key: 'drumSubShape', label: 'Shape', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumSubDrive', label: 'Drive', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumSubSub', label: 'Sub Oct', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
      ],
      'Envelope': [
        { key: 'drumSubAttack', label: 'Attack', min: 0, max: 5000, step: 1, unit: 'ms', def: 0, curve: 'attack' },
        { key: 'drumSubDecay', label: 'Decay', min: 10, max: 2800, step: 1, unit: 'ms', def: 150 },
        { key: 'drumSubLevel', label: 'Level', min: 0, max: 1, step: 0.01, unit: '%', def: 0.8 },
      ],
      'Pitch Env': [
        { key: 'drumSubPitchEnv', label: 'Amount', min: 0, max: 48, step: 1, unit: 'st', def: 0 },
        { key: 'drumSubPitchDecay', label: 'Decay', min: 1, max: 500, step: 1, unit: 'ms', def: 50 },
      ],
      'Variation': [
        { key: 'drumSubVariation', label: 'Variation', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumSubDistance', label: 'Distance', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
    }
  },
  kick: {
    label: 'Kick', icon: '●\uFE0E', color: '#f97316',
    sections: {
      'Tone': [
        { key: 'drumKickFreq', label: 'Frequency', min: 30, max: 120, step: 1, unit: 'Hz', def: 55 },
        { key: 'drumKickClick', label: 'Click', min: 0, max: 1, step: 0.01, unit: '%', def: 0.3 },
        { key: 'drumKickBody', label: 'Body', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
        { key: 'drumKickPunch', label: 'Punch', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
        { key: 'drumKickTail', label: 'Tail', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumKickTone', label: 'Tone', min: 0, max: 1.5, step: 0.01, unit: '%', def: 0 },
      ],
      'Envelope': [
        { key: 'drumKickAttack', label: 'Attack', min: 0, max: 5000, step: 1, unit: 'ms', def: 0, curve: 'attack' },
        { key: 'drumKickDecay', label: 'Decay', min: 20, max: 2800, step: 1, unit: 'ms', def: 200 },
        { key: 'drumKickLevel', label: 'Level', min: 0, max: 1, step: 0.01, unit: '%', def: 0.7 },
      ],
      'Pitch Env': [
        { key: 'drumKickPitchEnv', label: 'Amount', min: 0, max: 48, step: 1, unit: 'st', def: 24 },
        { key: 'drumKickPitchDecay', label: 'Decay', min: 1, max: 500, step: 1, unit: 'ms', def: 30 },
      ],
      'Variation': [
        { key: 'drumKickVariation', label: 'Variation', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumKickDistance', label: 'Distance', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
    }
  },
  click: {
    label: 'Click', icon: '▪\uFE0E', color: '#eab308',
    sections: {
      'Tone': [
        { key: 'drumClickPitch', label: 'Pitch', min: 500, max: 15000, step: 10, unit: 'Hz', def: 2000 },
        { key: 'drumClickFilter', label: 'Filter', min: 500, max: 20000, step: 10, unit: 'Hz', def: 4000 },
        { key: 'drumClickTone', label: 'Tone', min: 0, max: 1.5, step: 0.01, unit: '%', def: 0.3 },
        { key: 'drumClickResonance', label: 'Resonance', min: 0, max: 1, step: 0.01, unit: '%', def: 0.4 },
        { key: 'drumClickExciterColor', label: 'Exciter Color', min: -1, max: 1, step: 0.01, unit: '', def: 0 },
      ],
      'Mode': [
        { key: 'drumClickMode', label: 'Mode', type: 'select', options: ['impulse','noise','tonal','granular'], def: 'impulse' },
        { key: 'drumClickGrainCount', label: 'Grains', min: 1, max: 8, step: 1, unit: '', def: 1 },
        { key: 'drumClickGrainSpread', label: 'Grain Spread', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumClickStereoWidth', label: 'Stereo Width', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
      ],
      'Envelope': [
        { key: 'drumClickAttack', label: 'Attack', min: 0, max: 5000, step: 1, unit: 'ms', def: 0, curve: 'attack' },
        { key: 'drumClickDecay', label: 'Decay', min: 1, max: 140, step: 1, unit: 'ms', def: 5 },
        { key: 'drumClickLevel', label: 'Level', min: 0, max: 1, step: 0.01, unit: '%', def: 0.6 },
        { key: 'drumClickPitchEnv', label: 'Pitch Env', min: 0, max: 48, step: 1, unit: 'st', def: 0 },
      ],
      'Variation': [
        { key: 'drumClickVariation', label: 'Variation', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumClickDistance', label: 'Distance', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
    }
  },
  beepHi: {
    label: 'BeepHi', icon: '△\uFE0E', color: '#22c55e',
    sections: {
      'Tone': [
        { key: 'drumBeepHiFreq', label: 'Frequency', min: 200, max: 12000, step: 10, unit: 'Hz', def: 4000 },
        { key: 'drumBeepHiTone', label: 'Tone', min: 0, max: 1.5, step: 0.01, unit: '%', def: 0.2 },
        { key: 'drumBeepHiInharmonic', label: 'Inharmonic', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepHiPartials', label: 'Partials', min: 1, max: 8, step: 1, unit: '', def: 1 },
        { key: 'drumBeepHiBrightness', label: 'Brightness', min: 0, max: 1.5, step: 0.01, unit: '%', def: 0.5 },
      ],
      'FM Synthesis': [
        { key: 'drumBeepHiModRatio', label: 'Mod Ratio', min: 0.5, max: 12, step: 0.5, unit: ':1', def: 2 },
        { key: 'drumBeepHiModRatioFine', label: 'Ratio Fine', min: -0.5, max: 0.5, step: 0.01, unit: '', def: 0.01 },
        { key: 'drumBeepHiModPhase', label: 'Mod Phase', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepHiFeedback', label: 'FM Feedback', min: -1, max: 1, step: 0.01, unit: '', def: 0 },
        { key: 'drumBeepHiModEnvDecay', label: 'Mod Env Decay', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepHiModEnvEnd', label: 'Mod Env End', min: 0, max: 1, step: 0.01, unit: '%', def: 0.2 },
        { key: 'drumBeepHiNoiseInMod', label: 'Noise in Mod', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepHiNoiseDecay', label: 'Noise Decay', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
      ],
      'Shimmer': [
        { key: 'drumBeepHiShimmer', label: 'Amount', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepHiShimmerRate', label: 'Rate', min: 0.5, max: 20, step: 0.1, unit: 'Hz', def: 4 },
      ],
      'Envelope': [
        { key: 'drumBeepHiAttack', label: 'Attack', min: 0, max: 5000, step: 1, unit: 'ms', def: 1, curve: 'attack' },
        { key: 'drumBeepHiDecay', label: 'Decay', min: 10, max: 2800, step: 1, unit: 'ms', def: 80 },
        { key: 'drumBeepHiLevel', label: 'Level', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
      'Variation': [
        { key: 'drumBeepHiVariation', label: 'Variation', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepHiDistance', label: 'Distance', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
    }
  },
  beepLo: {
    label: 'BeepLo', icon: '▽\uFE0E', color: '#06b6d4',
    sections: {
      'Tone': [
        { key: 'drumBeepLoFreq', label: 'Frequency', min: 40, max: 800, step: 1, unit: 'Hz', def: 400 },
        { key: 'drumBeepLoTone', label: 'Tone', min: 0, max: 1.5, step: 0.01, unit: '%', def: 0.1 },
        { key: 'drumBeepLoBody', label: 'Body', min: 0, max: 1, step: 0.01, unit: '%', def: 0.3 },
      ],
      'Modal Resonator': [
        { key: 'drumBeepLoModal', label: 'Modal Mix', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepLoModalGain', label: 'Modal Gain', min: 0, max: 2, step: 0.01, unit: 'x', def: 1 },
        { key: 'drumBeepLoModalQ', label: 'Modal Q', min: 1, max: 60, step: 1, unit: '', def: 10 },
        { key: 'drumBeepLoModalInharmonic', label: 'Inharmonic', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepLoModalSpread', label: 'Spread', min: -1, max: 1, step: 0.01, unit: '', def: 0 },
        { key: 'drumBeepLoModalCut', label: 'Cut / Tilt', min: -1, max: 1, step: 0.01, unit: '', def: 0 },
      ],
      'Pluck': [
        { key: 'drumBeepLoOscGain', label: 'Osc Gain', min: 0, max: 2, step: 0.01, unit: 'x', def: 1 },
        { key: 'drumBeepLoPluck', label: 'Pluck', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepLoPluckDamp', label: 'Damp', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
      'Pitch Env': [
        { key: 'drumBeepLoPitchEnv', label: 'Amount', min: 0, max: 24, step: 1, unit: 'st', def: 0 },
        { key: 'drumBeepLoPitchDecay', label: 'Decay', min: 1, max: 500, step: 1, unit: 'ms', def: 50 },
      ],
      'Envelope': [
        { key: 'drumBeepLoAttack', label: 'Attack', min: 0, max: 5000, step: 1, unit: 'ms', def: 2, curve: 'attack' },
        { key: 'drumBeepLoDecay', label: 'Decay', min: 10, max: 2800, step: 1, unit: 'ms', def: 100 },
        { key: 'drumBeepLoLevel', label: 'Level', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
      'Variation': [
        { key: 'drumBeepLoVariation', label: 'Variation', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumBeepLoDistance', label: 'Distance', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
    }
  },
  noise: {
    label: 'Noise', icon: '≋\uFE0E', color: '#8b5cf6',
    sections: {
      'Filter': [
        { key: 'drumNoiseFilterFreq', label: 'Frequency', min: 100, max: 20000, step: 10, unit: 'Hz', def: 8000 },
        { key: 'drumNoiseFilterQ', label: 'Q', min: 0.1, max: 20, step: 0.1, unit: '', def: 1 },
        { key: 'drumNoiseFilterType', label: 'Type', type: 'select', options: ['lowpass','bandpass','highpass'], def: 'highpass' },
        { key: 'drumNoiseFilterEnv', label: 'Filter Env', min: -1, max: 1, step: 0.01, unit: '', def: 0 },
        { key: 'drumNoiseFilterEnvDecay', label: 'Env Decay', min: 5, max: 2000, step: 1, unit: 'ms', def: 100 },
        { key: 'drumNoiseColorLFO', label: 'Color LFO', min: 0, max: 20, step: 0.1, unit: 'Hz', def: 0 },
      ],
      'Texture': [
        { key: 'drumNoiseDensity', label: 'Density', min: 0, max: 1, step: 0.01, unit: '%', def: 1 },
        { key: 'drumNoiseFormant', label: 'Formant', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumNoiseBreath', label: 'Breath', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
      ],
      'Particle': [
        { key: 'drumNoiseParticleSize', label: 'Grain Size', min: 1, max: 50, step: 1, unit: 'ms', def: 5 },
        { key: 'drumNoiseParticleRandom', label: 'Random', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumNoiseParticleRandomRate', label: 'Random Rate', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
      'Ratchet': [
        { key: 'drumNoiseRatchetCount', label: 'Count', min: 0, max: 8, step: 1, unit: '', def: 0 },
        { key: 'drumNoiseRatchetTime', label: 'Time', min: 5, max: 100, step: 1, unit: 'ms', def: 30 },
      ],
      'Envelope': [
        { key: 'drumNoiseAttack', label: 'Attack', min: 0, max: 5000, step: 1, unit: 'ms', def: 0, curve: 'attack' },
        { key: 'drumNoiseDecay', label: 'Decay', min: 5, max: 2800, step: 1, unit: 'ms', def: 30 },
        { key: 'drumNoiseLevel', label: 'Level', min: 0, max: 1, step: 0.01, unit: '%', def: 0.4 },
      ],
      'Variation': [
        { key: 'drumNoiseVariation', label: 'Variation', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumNoiseDistance', label: 'Distance', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
    }
  },
  membrane: {
    label: 'Membrane', icon: '◎\uFE0E', color: '#e11d48',
    sections: {
      'Exciter': [
        { key: 'drumMembraneExciter', label: 'Type', type: 'select', options: ['impulse','noise','stick','brush','mallet'], def: 'impulse' },
        { key: 'drumMembraneExcPos', label: 'Position', min: 0, max: 1, step: 0.01, unit: '%', def: 0.3 },
        { key: 'drumMembraneExcBright', label: 'Brightness', min: 0, max: 1.5, step: 0.01, unit: '%', def: 0.5 },
        { key: 'drumMembraneExcDur', label: 'Duration', min: 0.5, max: 50, step: 0.5, unit: 'ms', def: 3 },
      ],
      'Membrane': [
        { key: 'drumMembraneSize', label: 'Size', min: 40, max: 600, step: 1, unit: 'Hz', def: 180 },
        { key: 'drumMembraneTension', label: 'Tension', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
        { key: 'drumMembraneDamping', label: 'Damping', min: 0, max: 1, step: 0.01, unit: '%', def: 0.3 },
        { key: 'drumMembraneMaterial', label: 'Material', type: 'select', options: ['skin','metal','wood','glass','plastic'], def: 'skin' },
        { key: 'drumMembraneNonlin', label: 'Nonlinearity', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
      ],
      'Wire Buzz': [
        { key: 'drumMembraneWireMix', label: 'Mix', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumMembraneWireDensity', label: 'Density', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
        { key: 'drumMembraneWireTone', label: 'Tone', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
        { key: 'drumMembraneWireDecay', label: 'Decay', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
      'Tone': [
        { key: 'drumMembraneBody', label: 'Body', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
        { key: 'drumMembraneRing', label: 'Ring', min: 0, max: 1, step: 0.01, unit: '%', def: 0.2 },
        { key: 'drumMembraneOvertones', label: 'Overtones', min: 1, max: 8, step: 1, unit: '', def: 4 },
      ],
      'Pitch Env': [
        { key: 'drumMembranePitchEnv', label: 'Amount', min: 0, max: 24, step: 1, unit: 'st', def: 3 },
        { key: 'drumMembranePitchDecay', label: 'Decay', min: 1, max: 500, step: 1, unit: 'ms', def: 40 },
      ],
      'Envelope': [
        { key: 'drumMembraneAttack', label: 'Attack', min: 0, max: 5000, step: 1, unit: 'ms', def: 0, curve: 'attack' },
        { key: 'drumMembraneDecay', label: 'Decay', min: 10, max: 7000, step: 1, unit: 'ms', def: 250 },
        { key: 'drumMembraneLevel', label: 'Level', min: 0, max: 1, step: 0.01, unit: '%', def: 0.6 },
      ],
      'Variation': [
        { key: 'drumMembraneVariation', label: 'Variation', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumMembraneDistance', label: 'Distance', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
    }
  },
  freeze: {
    label: 'Freeze', icon: '❄\uFE0E', color: '#0ea5e9',
    sections: {
      'Exciter': [
        { key: 'drumFreezeExciter', label: 'Type', type: 'select', options: ['impulse','noise','tone','pluck'], def: 'impulse' },
        { key: 'drumFreezeExcFreq', label: 'Pitch', min: 60, max: 8000, step: 10, unit: 'Hz', def: 440 },
        { key: 'drumFreezeExcBright', label: 'Brightness', min: 0, max: 1.5, step: 0.01, unit: '%', def: 0.5 },
      ],
      'Freeze': [
        { key: 'drumFreezeAmount', label: 'Amount', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
        { key: 'drumFreezeGrainSize', label: 'Grain Size', min: 5, max: 200, step: 1, unit: 'ms', def: 40 },
        { key: 'drumFreezeDensity', label: 'Density', min: 1, max: 32, step: 1, unit: '', def: 8 },
        { key: 'drumFreezeSpread', label: 'Spread', min: 0, max: 1, step: 0.01, unit: '%', def: 0.3 },
        { key: 'drumFreezeJitter', label: 'Jitter', min: 0, max: 1, step: 0.01, unit: '%', def: 0.1 },
      ],
      'Spectral': [
        { key: 'drumFreezeTilt', label: 'Tilt', min: -1, max: 1, step: 0.01, unit: '', def: 0 },
        { key: 'drumFreezeFormant', label: 'Formant', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumFreezePitchShift', label: 'Pitch Shift', min: -24, max: 24, step: 1, unit: 'st', def: 0 },
        { key: 'drumFreezeShimmer', label: 'Shimmer', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumFreezeShimmerRate', label: 'Shimmer Rate', min: 0.1, max: 12, step: 0.1, unit: 'Hz', def: 3 },
      ],
      'Filter': [
        { key: 'drumFreezeFilterFreq', label: 'Frequency', min: 100, max: 16000, step: 10, unit: 'Hz', def: 8000 },
        { key: 'drumFreezeFilterQ', label: 'Q', min: 0.1, max: 15, step: 0.1, unit: '', def: 0.7 },
        { key: 'drumFreezeFilterType', label: 'Type', type: 'select', options: ['lowpass','bandpass','highpass'], def: 'lowpass' },
      ],
      'Envelope': [
        { key: 'drumFreezeAttack', label: 'Attack', min: 0, max: 5000, step: 1, unit: 'ms', def: 10, curve: 'attack' },
        { key: 'drumFreezeDecay', label: 'Decay', min: 50, max: 11200, step: 10, unit: 'ms', def: 1200 },
        { key: 'drumFreezeLevel', label: 'Level', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
      'Variation': [
        { key: 'drumFreezeVariation', label: 'Variation', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
        { key: 'drumFreezeDistance', label: 'Distance', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
      ],
    }
  }
};

const DELAY_PARAMS = [
  { key: 'drumDelayNoteL', label: 'Note L', type: 'select', options: ['1/16','1/8','1/8d','1/4','1/4d','3/8','1/2'], def: '1/8d' },
  { key: 'drumDelayNoteR', label: 'Note R', type: 'select', options: ['1/16','1/8','1/8d','1/4','1/4d','3/8','1/2'], def: '1/4' },
  { key: 'drumDelayFeedback', label: 'Feedback', min: 0, max: 0.95, step: 0.01, unit: '%', def: 0.4 },
  { key: 'drumDelayMix', label: 'Mix', min: 0, max: 1, step: 0.01, unit: '%', def: 0.3 },
  { key: 'drumDelayFilter', label: 'Filter', min: 0, max: 1, step: 0.01, unit: '%', def: 0.5 },
];

// ══════════════════════════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════════════════════════

const state = {};       // Current param values (flat key→value)
const presets = {};     // Loaded presets per voice
let activeVoice = 'sub';

// ══════════════════════════════════════════════════════════════════
// SEEDED RNG — deterministic random for sequencer & evolution
// Uses mulberry32 (fast, good distribution). Matches src/audio/rng.ts policy.
// Math.random() is only used for audio synthesis buffers where reproducibility
// is not needed. All sequencer/evolution paths use seqRng().
// ══════════════════════════════════════════════════════════════════
function xmur3(str) {
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++) {
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = h << 13 | h >>> 19;
  }
  return function() {
    h = Math.imul(h ^ h >>> 16, 2246822507);
    h = Math.imul(h ^ h >>> 13, 3266489909);
    return (h ^= h >>> 16) >>> 0;
  };
}

function mulberry32(seed) {
  let s = seed | 0;
  return function() {
    s = s + 0x6D2B79F5 | 0;
    let t = Math.imul(s ^ s >>> 15, 1 | s);
    t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  };
}

// Global seeded RNG for sequencer — re-seedable for reproducibility
let _seqRngSeed = Date.now();
let _seqRng = mulberry32(xmur3(String(_seqRngSeed))());

function seqRng() { return _seqRng(); }
function seqRngInt(max) { return Math.floor(_seqRng() * max); }
function seqReSeed(seed) { _seqRngSeed = seed; _seqRng = mulberry32(xmur3(String(seed))()); }

// ══════════════════════════════════════════════════════════════════
// EXPONENTIAL ATTACK CURVE: 75% slider = 0-100ms, 25% = 100-5000ms
// ══════════════════════════════════════════════════════════════════

function attackSliderToMs(pos) {
  if (pos <= 0) return 0;
  if (pos <= 0.75) return (pos / 0.75) * 100;
  const t = (pos - 0.75) / 0.25;
  return 100 + t * t * 4900;
}

function attackMsToSlider(ms) {
  if (ms <= 0) return 0;
  if (ms <= 100) return (ms / 100) * 0.75;
  return 0.75 + Math.sqrt(Math.min(1, (ms - 100) / 4900)) * 0.25;
}

// ══════════════════════════════════════════════════════════════════
// UI BUILDERS
// ══════════════════════════════════════════════════════════════════

function formatVal(p, val) {
  if (p.unit === '%') return Math.round(val * 100) + '%';
  if (p.unit === 'Hz') return val >= 1000 ? (val/1000).toFixed(1) + 'k' : val + '';
  if (p.unit === 'ms') return val + 'ms';
  if (p.unit === 'st') return val + 'st';
  if (p.unit === ':1') return val.toFixed(1) + ':1';
  return typeof val === 'number' ? (Number.isInteger(val) ? val : val.toFixed(2)) : val;
}

function createParamRow(p) {
  const row = document.createElement('div');
  row.className = 'param-row';
  
  if (p.type === 'select') {
    row.innerHTML = `
      <label>${p.label}</label>
      <select data-key="${p.key}">
        ${p.options.map(o => `<option value="${o}" ${o === p.def ? 'selected' : ''}>${o}</option>`).join('')}
      </select>`;
    const sel = row.querySelector('select');
    state[p.key] = p.def;
    sel.addEventListener('change', () => { state[p.key] = sel.value; drawEnvelopes(activeVoice); });
  } else if (p.curve === 'attack') {
    // Exponential attack slider: 75% of travel = 0-100ms, 25% = 100-5000ms
    const val = p.def;
    state[p.key] = val;
    const sliderPos = attackMsToSlider(val);
    row.innerHTML = `
      <label>${p.label}</label>
      <input type="range" min="0" max="1" step="0.001" value="${sliderPos}" data-key="${p.key}" data-curve="attack">
      <span class="val">${formatVal(p, val)}</span>`;
    const slider = row.querySelector('input');
    const valSpan = row.querySelector('.val');
    slider.addEventListener('input', () => {
      const ms = Math.round(attackSliderToMs(parseFloat(slider.value)));
      state[p.key] = ms;
      valSpan.textContent = formatVal(p, ms);
      drawEnvelopes(activeVoice);
    });
  } else {
    const val = p.def;
    state[p.key] = val;
    row.innerHTML = `
      <label>${p.label}</label>
      <input type="range" min="${p.min}" max="${p.max}" step="${p.step}" value="${val}" data-key="${p.key}">
      <span class="val">${formatVal(p, val)}</span>`;
    const slider = row.querySelector('input');
    const valSpan = row.querySelector('.val');
    slider.addEventListener('input', () => {
      const v = parseFloat(slider.value);
      state[p.key] = v;
      valSpan.textContent = formatVal(p, v);
      drawEnvelopes(activeVoice);
    });
  }
  return row;
}

function createSection(name, params) {
  const sec = document.createElement('div');
  sec.className = 'param-section';
  const header = document.createElement('div');
  header.className = 'section-header';
  header.textContent = name;
  const body = document.createElement('div');
  body.className = 'section-body';
  header.addEventListener('click', () => {
    header.classList.toggle('collapsed');
    body.classList.toggle('collapsed');
  });
  params.forEach(p => body.appendChild(createParamRow(p)));
  sec.appendChild(header);
  sec.appendChild(body);
  return sec;
}

// ══════════════════════════════════════════════════════════════════
// BUILD VOICE TABS & PANELS
// ══════════════════════════════════════════════════════════════════

const tabContainer = document.getElementById('voiceTabs');
const panelContainer = document.getElementById('voicePanels');

function buildVoice(voiceKey) {
  const v = VOICES[voiceKey];
  
  // Tab button
  const tab = document.createElement('button');
  tab.className = 'voice-tab';
  tab.dataset.voice = voiceKey;
  tab.innerHTML = `<span class="icon">${v.icon}</span>${v.label}`;
  tab.addEventListener('click', () => switchVoice(voiceKey));
  tabContainer.appendChild(tab);
  
  // Panel
  const panel = document.createElement('div');
  panel.className = 'voice-panel';
  panel.id = `panel-${voiceKey}`;
  
  // Trigger row
  const trigRow = document.createElement('div');
  trigRow.className = 'trigger-row';
  trigRow.innerHTML = `<button class="trigger-btn" data-voice="${voiceKey}">▶ Trigger ${v.label}</button>`;
  panel.appendChild(trigRow);
  
  // Morph row
  const morphRow = document.createElement('div');
  morphRow.className = 'morph-row';
  morphRow.innerHTML = `
    <span class="morph-label">A</span>
    <select id="presetA-${voiceKey}" data-voice="${voiceKey}" data-slot="A"></select>
    <input type="range" min="0" max="1" step="0.01" value="0" id="morph-${voiceKey}" data-key="morph-${voiceKey}">
    <select id="presetB-${voiceKey}" data-voice="${voiceKey}" data-slot="B"></select>
    <span class="morph-label">B</span>`;
  panel.appendChild(morphRow);

  // Envelope visualizer canvas
  const vizWrap = document.createElement('div');
  vizWrap.className = 'env-visualizer-wrap';
  const vizCanvas = document.createElement('canvas');
  vizCanvas.className = 'env-visualizer';
  vizCanvas.id = `viz-${voiceKey}`;
  const vizLabel = document.createElement('div');
  vizLabel.className = 'viz-mode-label';
  vizLabel.id = `viz-label-${voiceKey}`;
  vizLabel.textContent = 'envelopes';
  vizWrap.appendChild(vizCanvas);
  vizWrap.appendChild(vizLabel);
  panel.appendChild(vizWrap);
  
  // Delay send
  const capVoice = voiceKey.charAt(0).toUpperCase() + voiceKey.slice(1);
  const delayKey = `drum${capVoice}DelaySend`;
  
  // Param sections
  for (const [secName, params] of Object.entries(v.sections)) {
    panel.appendChild(createSection(secName, params));
  }
  
  // Delay send at bottom
  const sendSec = createSection('Send', [
    { key: delayKey, label: 'Delay Send', min: 0, max: 1, step: 0.01, unit: '%', def: 0 },
  ]);
  panel.appendChild(sendSec);
  
  panelContainer.appendChild(panel);
}

Object.keys(VOICES).forEach(v => buildVoice(v));

function switchVoice(voiceKey) {
  activeVoice = voiceKey;
  document.querySelectorAll('.voice-tab').forEach(t => t.classList.toggle('active', t.dataset.voice === voiceKey));
  document.querySelectorAll('.voice-panel').forEach(p => p.classList.toggle('active', p.id === `panel-${voiceKey}`));
  requestAnimationFrame(() => drawEnvelopes(voiceKey));
}
switchVoice('sub');

// ══════════════════════════════════════════════════════════════════
// BUILD DELAY SECTION
// ══════════════════════════════════════════════════════════════════

const delayBody = document.getElementById('delayBody');
DELAY_PARAMS.forEach(p => delayBody.appendChild(createParamRow(p)));

// ══════════════════════════════════════════════════════════════════
// MASTER STRIP WIRING
// ══════════════════════════════════════════════════════════════════

document.getElementById('masterLevel').addEventListener('input', function() {
  document.getElementById('masterLevelVal').textContent = Math.round(this.value * 100) + '%';
  state.drumLevel = parseFloat(this.value);
  if (masterGainNode) {
    masterGainNode.gain.setValueAtTime(state.drumLevel, audioCtx.currentTime);
  }
});
document.getElementById('masterReverb').addEventListener('input', function() {
  document.getElementById('masterReverbVal').textContent = Math.round(this.value * 100) + '%';
  state.drumReverbSend = parseFloat(this.value);
});

state.drumLevel = parseFloat(document.getElementById('masterLevel').value);
state.drumReverbSend = parseFloat(document.getElementById('masterReverb').value);

// ══════════════════════════════════════════════════════════════════
// PRESET LOADING
// ══════════════════════════════════════════════════════════════════

async function loadPresets() {
  const voices = ['sub','kick','click','beepHi','beepLo','noise','membrane','freeze'];
  let totalCount = 0;
  
  for (const v of voices) {
    try {
      const resp = await fetch(`presets/DrumSynth/${v}.json`);
      const data = await resp.json();
      presets[v] = data;
      totalCount += data.length;
      
      // Populate preset selects
      const selA = document.getElementById(`presetA-${v}`);
      const selB = document.getElementById(`presetB-${v}`);
      if (selA && selB) {
        data.forEach((p, i) => {
          selA.add(new Option(p.name, i));
          selB.add(new Option(p.name, i));
        });
        // Set B to second preset if available
        if (data.length > 1) selB.selectedIndex = 1;
        
        // Wire preset change events
        selA.addEventListener('change', () => applyPreset(v, 'A'));
        selB.addEventListener('change', () => applyPreset(v, 'B'));
        
        // Wire morph slider
        const morphSlider = document.getElementById(`morph-${v}`);
        morphSlider.addEventListener('input', () => applyMorph(v));
      }
      
      // Apply first preset
      applyPresetData(v, data[0]);
    } catch (e) {
      console.warn(`Failed to load presets for ${v}:`, e);
      presets[v] = [];
    }
  }
  
  document.getElementById('presetCount').textContent = totalCount;

  // Initial envelope draw for active voice
  requestAnimationFrame(() => drawEnvelopes(activeVoice));
}

function applyPresetData(voiceKey, preset) {
  if (!preset || !preset.params) return;
  const macroKeysByVoice = {
    sub: { variation: 'drumSubVariation', distance: 'drumSubDistance' },
    kick: { variation: 'drumKickVariation', distance: 'drumKickDistance' },
    click: { variation: 'drumClickVariation', distance: 'drumClickDistance' },
    beepHi: { variation: 'drumBeepHiVariation', distance: 'drumBeepHiDistance' },
    beepLo: { variation: 'drumBeepLoVariation', distance: 'drumBeepLoDistance' },
    noise: { variation: 'drumNoiseVariation', distance: 'drumNoiseDistance' },
    membrane: { variation: 'drumMembraneVariation', distance: 'drumMembraneDistance' },
    freeze: { variation: 'drumFreezeVariation', distance: 'drumFreezeDistance' },
  };
  const locked = macroKeysByVoice[voiceKey] || null;

  const setParamValue = (key, val) => {
    state[key] = val;
    const el = document.querySelector(`[data-key="${key}"]`);
    if (!el) return;
    if (el.tagName === 'SELECT') {
      el.value = val;
      return;
    }
    if (el.dataset.curve === 'attack') {
      el.value = attackMsToSlider(val);
    } else {
      el.value = val;
    }
    const valSpan = el.parentElement.querySelector('.val');
    if (valSpan) {
      const pDef = findParamDef(key);
      if (pDef) valSpan.textContent = formatVal(pDef, val);
      else valSpan.textContent = typeof val === 'number' ? (Number.isInteger(val) ? val : val.toFixed(2)) : val;
    }
  };

  for (const [key, val] of Object.entries(preset.params)) {
    if (locked && (key === locked.variation || key === locked.distance)) continue;
    setParamValue(key, val);
  }

  // Keep Variation/Distance neutral while presets are loaded/morphed
  if (locked) {
    setParamValue(locked.variation, 0);
    setParamValue(locked.distance, 0.5);
  }
}

function findParamDef(key) {
  for (const v of Object.values(VOICES)) {
    for (const params of Object.values(v.sections)) {
      const found = params.find(p => p.key === key);
      if (found) return found;
    }
  }
  return null;
}

function applyPreset(voiceKey, slot) {
  const sel = document.getElementById(`preset${slot}-${voiceKey}`);
  const idx = parseInt(sel.value);
  const preset = presets[voiceKey]?.[idx];
  if (!preset) return;
  // If morph is at 0 and we're changing A, or morph at 1 and changing B, apply directly
  const morphSlider = document.getElementById(`morph-${voiceKey}`);
  const morph = parseFloat(morphSlider.value);
  if ((slot === 'A' && morph < 0.01) || (slot === 'B' && morph > 0.99)) {
    applyPresetData(voiceKey, preset);
  }
}

function applyMorph(voiceKey) {
  const morphSlider = document.getElementById(`morph-${voiceKey}`);
  const morph = parseFloat(morphSlider.value);
  const selA = document.getElementById(`presetA-${voiceKey}`);
  const selB = document.getElementById(`presetB-${voiceKey}`);
  const presetA = presets[voiceKey]?.[parseInt(selA.value)];
  const presetB = presets[voiceKey]?.[parseInt(selB.value)];
  if (!presetA || !presetB) return;
  
  // Interpolate numeric params
  const merged = {};
  const allKeys = new Set([...Object.keys(presetA.params), ...Object.keys(presetB.params)]);
  for (const key of allKeys) {
    const a = presetA.params[key];
    const b = presetB.params[key];
    if (typeof a === 'number' && typeof b === 'number') {
      merged[key] = a + (b - a) * morph;
    } else {
      merged[key] = morph < 0.5 ? (a ?? b) : (b ?? a);
    }
  }
  applyPresetData(voiceKey, { params: merged });
  drawEnvelopes(voiceKey);
}

loadPresets();

// ══════════════════════════════════════════════════════════════════
// ENVELOPE VISUALIZER
// ══════════════════════════════════════════════════════════════════

const ENV_COLORS = {
  amp: '#ffffff',
  pitch: '#f97316',
  filter: '#06b6d4',
  fmMod: '#22c55e',
  ratchet: '#c084fc',
};

function getEnvelopeCurves(voiceKey) {
  const s = (k) => state[k] ?? 0;
  const curves = [];

  // ── Amp envelope (normalized 0-1) ──
  function ampCurve(attackMs, decayMs, level, name) {
    const attack = Math.max(0.0001, attackMs / 1000);
    const decay = Math.max(0.005, decayMs / 1000);
    const totalTime = attack + decay;
    const pts = [];
    for (let i = 0; i < 200; i++) {
      const t = (i / 199) * totalTime;
      let v;
      if (t <= attack) {
        v = (t / attack) * level;
      } else {
        const elapsed = t - attack;
        v = level * Math.pow(0.0001 / Math.max(0.0001, level), elapsed / decay);
      }
      pts.push({ t, v: Math.max(0, Math.min(1, v)) });
    }
    return { name: name || 'Amp', color: ENV_COLORS.amp, points: pts, maxTime: totalTime };
  }

  // ── Pitch envelope (normalized 0-1 = full sweep to none) ──
  function pitchCurve(baseFreq, pitchSemitones, pitchDecayMs) {
    if (Math.abs(pitchSemitones) < 0.5) return null;
    const pitchDecay = Math.max(0.001, pitchDecayMs / 1000);
    const totalTime = pitchDecay * 1.2;
    const pts = [];
    for (let i = 0; i < 200; i++) {
      const t = (i / 199) * totalTime;
      const v = Math.exp(-t * 5 / pitchDecay);
      pts.push({ t, v: Math.max(0, Math.min(1, v)) });
    }
    return { name: 'Pitch', color: ENV_COLORS.pitch, points: pts, maxTime: totalTime };
  }

  // ── Filter envelope (normalized 0-1) ──
  function filterCurve(envAmount, envDecayMs) {
    if (Math.abs(envAmount) < 0.01) return null;
    const envDecay = Math.max(0.005, envDecayMs / 1000);
    const totalTime = envDecay * 1.2;
    const pts = [];
    for (let i = 0; i < 200; i++) {
      const t = (i / 199) * totalTime;
      const raw = Math.exp(-t * 5 / envDecay);
      pts.push({ t, v: Math.max(0, Math.min(1, raw)) });
    }
    return { name: 'Filter', color: ENV_COLORS.filter, points: pts, maxTime: totalTime };
  }

  switch (voiceKey) {
    case 'sub':
      curves.push(ampCurve(s('drumSubAttack') || 0, s('drumSubDecay') || 150, s('drumSubLevel') || 0.8));
      { const pc = pitchCurve(s('drumSubFreq') || 50, s('drumSubPitchEnv') || 0, s('drumSubPitchDecay') || 50);
        if (pc) curves.push(pc); }
      break;

    case 'kick':
      curves.push(ampCurve(s('drumKickAttack') || 0, s('drumKickDecay') || 200, s('drumKickLevel') || 0.7));
      { const pc = pitchCurve(s('drumKickFreq') || 55, s('drumKickPitchEnv') || 24, s('drumKickPitchDecay') || 30);
        if (pc) curves.push(pc); }
      break;

    case 'click':
      curves.push(ampCurve(s('drumClickAttack') || 0, s('drumClickDecay') || 5, s('drumClickLevel') || 0.6));
      { const pc = pitchCurve(s('drumClickPitch') || 2000, s('drumClickPitchEnv') || 0, (s('drumClickDecay') || 5) * 0.5);
        if (pc) curves.push(pc); }
      // Resonance indicator as filter curve
      { const res = s('drumClickResonance') || 0;
        if (res > 0.05) {
          const fc = filterCurve(res, s('drumClickDecay') || 5);
          if (fc) { fc.name = 'Resonance'; curves.push(fc); }
        }
      }
      break;

    case 'beepHi': {
      const bhAttack = s('drumBeepHiAttack') || 1;
      const bhDecay = s('drumBeepHiDecay') || 80;
      curves.push(ampCurve(bhAttack, bhDecay, s('drumBeepHiLevel') || 0.5));
      // FM modulation envelope
      const modEnvDecay = s('drumBeepHiModEnvDecay') || 0;
      const modEnvEnd = s('drumBeepHiModEnvEnd') || 0.2;
      if (modEnvDecay > 0.01) {
        const modDur = modEnvDecay * Math.max(0.01, bhDecay / 1000);
        const totalTime = modDur * 1.2;
        const pts = [];
        for (let i = 0; i < 200; i++) {
          const t = (i / 199) * totalTime;
          const v = modEnvEnd + (1 - modEnvEnd) * Math.exp(-t * 5 / Math.max(0.001, modDur));
          pts.push({ t, v: Math.max(0, Math.min(1, v)) });
        }
        curves.push({ name: 'FM Mod', color: ENV_COLORS.fmMod, points: pts, maxTime: totalTime });
      }
      break;
    }

    case 'beepLo':
      curves.push(ampCurve(s('drumBeepLoAttack') || 2, s('drumBeepLoDecay') || 100, s('drumBeepLoLevel') || 0.5));
      { const pc = pitchCurve(s('drumBeepLoFreq') || 400, s('drumBeepLoPitchEnv') || 0, s('drumBeepLoPitchDecay') || 50);
        if (pc) curves.push(pc); }
      break;

    case 'noise': {
      const nAttack = s('drumNoiseAttack') || 0;
      const nDecay = s('drumNoiseDecay') || 30;
      const nLevel = s('drumNoiseLevel') || 0.4;
      const ratchetCount = Math.round(s('drumNoiseRatchetCount') || 0);
      const ratchetTime = (s('drumNoiseRatchetTime') || 30) / 1000;

      if (ratchetCount > 0) {
        // Multi-hit ratchet burst
        const singleDur = Math.max(0.0001, nAttack / 1000) + Math.max(0.005, nDecay / 1000);
        const totalTime = singleDur + ratchetCount * ratchetTime + 0.01;
        const pts = [];
        for (let i = 0; i < 300; i++) {
          const t = (i / 299) * totalTime;
          let v = 0;
          for (let r = 0; r <= ratchetCount; r++) {
            const hitTime = r * ratchetTime;
            const hitLevel = nLevel * Math.pow(0.75, r);
            const atk = Math.max(0.0001, nAttack / 1000);
            const dec = Math.max(0.005, nDecay / 1000);
            const el = t - hitTime;
            if (el >= 0) {
              if (el <= atk) {
                v += (el / atk) * hitLevel;
              } else {
                v += hitLevel * Math.pow(0.0001 / Math.max(0.0001, hitLevel), (el - atk) / dec);
              }
            }
          }
          pts.push({ t, v: Math.min(1, v) });
        }
        curves.push({ name: 'Amp+Ratchet', color: ENV_COLORS.amp, points: pts, maxTime: totalTime });
      } else {
        curves.push(ampCurve(nAttack, nDecay, nLevel));
      }

      // Filter envelope
      { const fc = filterCurve(s('drumNoiseFilterEnv') || 0, s('drumNoiseFilterEnvDecay') || 100);
        if (fc) curves.push(fc); }
      break;
    }

    case 'membrane': {
      const mAttack = s('drumMembraneAttack') || 0;
      const mDecay = s('drumMembraneDecay') || 250;
      const mLevel = s('drumMembraneLevel') || 0.6;
      curves.push(ampCurve(mAttack, mDecay, mLevel));
      { const pc = pitchCurve(s('drumMembraneSize') || 180, s('drumMembranePitchEnv') || 3, s('drumMembranePitchDecay') || 40);
        if (pc) curves.push(pc); }
      // Wire buzz decay
      const wireMix = s('drumMembraneWireMix') || 0;
      if (wireMix > 0.01) {
        const wireDecFrac = s('drumMembraneWireDecay') || 0.5;
        const wireDur = (mDecay / 1000) * (0.3 + wireDecFrac * 1.4);
        const pts = [];
        for (let i = 0; i < 100; i++) {
          const t = (i / 99) * wireDur * 1.2;
          const v = wireMix * 0.5 * Math.exp(-t * 3 / Math.max(0.01, wireDur));
          pts.push({ t, v: Math.max(0, Math.min(1, v)) });
        }
        curves.push({ name: 'Wire', color: '#f472b6', points: pts, maxTime: wireDur * 1.2 });
      }
      break;
    }

    case 'freeze': {
      const fAttack = s('drumFreezeAttack') || 10;
      const fDecay = s('drumFreezeDecay') || 1200;
      const fLevel = s('drumFreezeLevel') || 0.5;
      curves.push(ampCurve(fAttack, fDecay, fLevel));
      // Grain density visualization
      const gSize = (s('drumFreezeGrainSize') || 40) / 1000;
      const gDensity = s('drumFreezeDensity') || 8;
      const totalDur = Math.max(0.001, fAttack / 1000) + Math.max(0.05, fDecay / 1000);
      const interval = gSize / Math.max(1, gDensity * 0.5);
      const pts = [];
      for (let i = 0; i < 150; i++) {
        const t = (i / 149) * totalDur;
        // Sawtooth-like grain bursts
        const phase = (t % interval) / interval;
        const grainEnv = 0.5 * (1 - Math.cos(2 * Math.PI * phase));
        const ampEnv = t < fAttack / 1000
          ? (t / (fAttack / 1000)) * fLevel
          : fLevel * Math.exp(-3 * (t - fAttack / 1000) / Math.max(0.05, fDecay / 1000));
        pts.push({ t, v: Math.max(0, Math.min(1, grainEnv * ampEnv * 1.5)) });
      }
      curves.push({ name: 'Grains', color: '#38bdf8', points: pts, maxTime: totalDur });
      break;
    }
  }

  return curves;
}

function drawEnvelopes(voiceKey) {
  const canvas = document.getElementById(`viz-${voiceKey}`);
  if (!canvas) return;

  // If spectrogram is currently active, don't overwrite
  const ss = spectrogramState[voiceKey];
  if (ss && (ss.capturing || ss.fadeAlpha > 0.01)) return;

  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  if (rect.width === 0) return;

  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  const w = rect.width;
  const h = rect.height;
  const pad = { top: 14, right: 8, bottom: 14, left: 8 };

  ctx.clearRect(0, 0, w, h);

  // In idle mode, envelope curves get the full canvas height
  drawEnvelopeRegion(ctx, voiceKey, pad.left, pad.top, w - pad.left - pad.right, h - pad.top - pad.bottom);

  // Idle label: show "trigger to analyze"
  ctx.fillStyle = 'rgba(255,255,255,0.12)';
  ctx.font = '8px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('trigger voice to show live spectrum', w / 2, h - 3);
}

// ══════════════════════════════════════════════════════════════════
// AUDIO TEST ENGINE
// ══════════════════════════════════════════════════════════════════

let audioCtx = null;
let masterGainNode = null;
let noiseBuffer = null;
let analyserNode = null;
let analyserData = null;      // Uint8Array for FFT
let analyserWaveform = null;  // Uint8Array for waveform

// Spectrogram state per voice
const spectrogramState = {};
const SPECT_COLS_DEFAULT = 128;  // Default number of time columns in spectrogram
const SPECT_CAPTURE_MS = 25;     // ms between FFT captures
const SPECT_DURATION_MS_DEFAULT = 1500; // default capture window (short sounds)

// Compute capture duration dynamically from voice envelope
function getVoiceCaptureDuration(voiceKey) {
  const curves = getEnvelopeCurves(voiceKey);
  const maxTimeSec = curves.length > 0 ? Math.max(...curves.map(c => c.maxTime)) : 1.5;
  const durationMs = maxTimeSec * 1000 + 200; // +200ms buffer
  return Math.max(SPECT_DURATION_MS_DEFAULT, durationMs);
}

// Per-voice frequency ceiling (Hz) — spectrogram zooms into this range
const VOICE_FREQ_CEILING = {
  sub:      400,    // fundamental 20-100 Hz + harmonics
  kick:     800,    // fundamental 30-120 Hz + click transient
  click:    12000,  // wide-band transient, up to 12kHz
  beepHi:   16000,  // FM partials can reach high
  beepLo:   4000,   // fundamental 40-800 Hz + modal overtones
  noise:    18000,  // broadband noise, show most of spectrum
  membrane: 6000,   // membrane modes + wire buzz harmonics
  freeze:   16000,  // granular spectral content
};

function createNoiseBuffer(ctx) {
  const len = Math.floor(ctx.sampleRate * 0.2);
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < len; i++) {
    data[i] = Math.random() * 2 - 1;
  }
  return buf;
}

async function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGainNode = audioCtx.createGain();
    masterGainNode.gain.value = state.drumLevel ?? 0.7;

    // Insert AnalyserNode between master gain and destination
    analyserNode = audioCtx.createAnalyser();
    analyserNode.fftSize = 2048;
    analyserNode.smoothingTimeConstant = 0.3;
    analyserNode.minDecibels = -90;
    analyserNode.maxDecibels = -10;
    analyserData = new Uint8Array(analyserNode.frequencyBinCount);
    analyserWaveform = new Uint8Array(analyserNode.fftSize);

    masterGainNode.connect(analyserNode);
    analyserNode.connect(audioCtx.destination);
    noiseBuffer = createNoiseBuffer(audioCtx);

    // Auto-disconnect source nodes after they stop, preventing zombie node accumulation.
    // This covers ALL voice trigger functions without requiring per-function cleanup.
    [OscillatorNode, AudioBufferSourceNode].forEach(Cls => {
      const origStop = Cls.prototype.stop;
      Cls.prototype.stop = function(when) {
        origStop.call(this, when);
        const self = this;
        const ms = Math.max(50, ((when || audioCtx.currentTime) - audioCtx.currentTime + 0.15) * 1000);
        setTimeout(() => { try { self.disconnect(); } catch(e) {} }, ms);
      };
    });
  }
  if (audioCtx.state === 'suspended') {
    await audioCtx.resume();
  }
}

function applyEnv(gainNode, time, attack, decay, level) {
  gainNode.gain.cancelScheduledValues(time);
  gainNode.gain.setValueAtTime(0.0001, time);
  gainNode.gain.linearRampToValueAtTime(Math.max(0.0001, level), time + Math.max(0.001, attack));
  gainNode.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.01, attack + decay));
}

// ── Waveshaper curve helper (matches drumSynth.ts tanh saturation) ──
function makeWaveshaperCurve(driveAmount) {
  const samples = 256;
  const curve = new Float32Array(samples);
  if (driveAmount < 0.001) {
    for (let i = 0; i < samples; i++) curve[i] = (i * 2) / samples - 1;
    return curve;
  }
  const denom = Math.tanh(driveAmount);
  for (let i = 0; i < samples; i++) {
    const x = (i * 2) / samples - 1;
    curve[i] = Math.tanh(x * driveAmount) / denom;
  }
  return curve;
}

// ════════════════════════════════════════════════════════════════
// PER-HIT VARIATION & DISTANCE HELPERS
// ════════════════════════════════════════════════════════════════

/**
 * Per-hit micro-randomness using correlated triangular distribution.
 * Returns multiplier struct: { vLevel, vDecay, vPitch, vBright, vAttack, vExcite }
 */
function computeVariation(variation) {
  if (variation < 0.001) return { vLevel: 1, vDecay: 1, vPitch: 1, vBright: 1, vAttack: 1, vExcite: 1 };
  // Correlated triangular noise: mean=0, range ≈ ±variation
  const base = (Math.random() + Math.random() - 1) * variation;
  return {
    vLevel:  1 + base * 0.60,            // ±60% amplitude
    vDecay:  1 + base * 0.40,            // ±40% decay
    vPitch:  1 + base * 0.02,            // ±2% (~32 cents)
    vBright: 1 + base * 0.80,            // ±80% brightness
    vAttack: 1 / (1 + base * 0.60),      // inverse — louder hits = shorter attack
    vExcite: 1 + base * 0.80,            // ±80% excitation energy
  };
}

/**
 * Strike-position macro: 0.0 = dead center, 0.5 = neutral, 1.0 = edge of head.
 * Returns multiplier struct: { dLevel, dDecay, dBright, dAttack, dTransient, dBody }
 */
// Strike position model: 0.0 = dead center, 0.5 = neutral (preset as-is), 1.0 = edge
// Center: more body/fundamental, longer decay, darker, rounder attack
// Edge:   thinner, shorter decay, brighter, sharper attack, more overtones
function computeDistance(distance) {
  const t = (distance - 0.5) * 2;  // -1 (center) to +1 (edge), 0 = neutral
  if (Math.abs(t) < 0.01) return { dLevel: 1, dDecay: 1, dBright: 1, dAttack: 1, dTransient: 1, dBody: 1, t: 0 };

  // Logarithmic brightness curve: log-compression prevents runaway
  // center (t=-1): ~0.22 (very dark), edge (t=+1): ~2.1 (bright, log-compressed)
  const dBright = t >= 0
    ? 1 + Math.log2(1 + t) * 1.1            // edge: reaches ~2.1 at t=1
    : 1 / (1 + Math.log2(1 + Math.abs(t)) * 3.5);  // center: reaches ~0.22

  return {
    dLevel:     1 - t * 0.4,                // center=1.4, edge=0.6
    dDecay:     t >= 0 ? 1 - t * 0.8 : 1 + Math.abs(t) * 7.0,  // center=8.0 (×8 sustain), edge=0.2 (very tight)
    dBright,                                 // center=very dark, edge=bright (log-compressed)
    dAttack:    t >= 0 ? 1 - t * 0.55 : 1 + Math.abs(t) * 1.0,  // center=2.0 (very round), edge=0.45 (snappy)
    dTransient: 1 + t * 0.85,               // center=0.15 (almost no click), edge=1.85 (hard click)
    dBody:      t >= 0 ? 1 - t * 0.6 : 1 + Math.abs(t) * 1.2,  // center=2.2 (huge body), edge=0.4 (thin)
    t,                                       // raw bipolar value for voice-specific mods
  };
}

// ── Centralized cl/ed (center-loosen / edge-dampen) coefficients ──
// Per-voice parameter modifiers for strike-position Distance macro.
// Each entry: [clCoeff, edCoeff, mode]
//   mode 'mul': value * (1 + cl*clCoeff) * (1 + ed*edCoeff)
//   mode 'add': value + cl*clCoeff + ed*edCoeff
// cl = max(0,-t), ed = max(0,t) where t = computeDistance().t
const CL_ED = {
  sub:      { drive: [-0.6, 0.4, 'mul'] },
  kick:     { pitchDecay: [0.8, -0.35, 'mul'], tail: [0.3, -0.15, 'add'] },
  click:    { resonance: [0.8, -0.5, 'mul'] },
  beepHi:   { bright: [0.6, 0.4, 'add'], shimmer: [0.4, 0, 'add'], feedback: [0.3, 0, 'add'] },
  beepLo:   { modalQ: [0.7, -0.5, 'mul'], modalGain: [0.5, 0, 'mul'] },
  noise:    { bright: [0.7, -0.7, 'add'], formant: [0.35, 0, 'add'], density: [0.4, -0.5, 'mul'] },
  membrane: { tension: [0.3, 0, 'add'], wireMix: [0.3, -0.2, 'add'], wireDecay: [0.35, 0, 'add'] },
  freeze:   { freezeAmt: [0.3, 0, 'add'], density: [0.8, -0.5, 'mul'], shimmer: [0.35, 0, 'add'] },
};
function clEd(val, t, cfg) {
  const cl = Math.max(0, -t), ed = Math.max(0, t);
  const [c, e, mode] = cfg;
  return mode === 'mul' ? val * (1 + cl*c) * (1 + ed*e) : val + cl*c + ed*e;
}

// ── Voice pool for polyphony limiting ──
const MAX_DECAY_SEC = 12;
const voicePools = {
  sub:      { max: 1, voices: [] },
  kick:     { max: 1, voices: [] },
  click:    { max: 4, voices: [] },
  beepHi:   { max: 3, voices: [] },
  beepLo:   { max: 3, voices: [] },
  noise:    { max: 2, voices: [] },
  membrane: { max: 2, voices: [] },
  freeze:   { max: 2, voices: [] },
};

function acquireVoice(poolName) {
  const pool = voicePools[poolName];
  const now = audioCtx.currentTime;
  // Disconnect and evict expired voices
  pool.voices = pool.voices.filter(v => {
    if (v.endTime > now) return true;
    try { v.outGain.disconnect(); } catch(e) {}
    return false;
  });
  // Steal oldest if at capacity — fast-fade to avoid click
  while (pool.voices.length >= pool.max) {
    const oldest = pool.voices.shift();
    if (oldest && oldest.outGain) {
      try {
        oldest.outGain.gain.cancelScheduledValues(now);
        oldest.outGain.gain.setValueAtTime(oldest.outGain.gain.value, now);
        oldest.outGain.gain.linearRampToValueAtTime(0, now + 0.005);
        setTimeout(() => { try { oldest.outGain.disconnect(); } catch(e) {} }, 50);
      } catch(e) {}
    }
  }
  // Create wrapper gain node for new voice
  const outGain = audioCtx.createGain();
  outGain.connect(masterGainNode);
  const entry = { outGain, endTime: now + MAX_DECAY_SEC + 1 };
  pool.voices.push(entry);
  return { outGain, entry };
}

// ════════════════════════════════════════════════════════════════
// Sub — matches drumSynth.ts: shape, tone (2nd harmonic), drive (waveshaper), sub-octave
// ════════════════════════════════════════════════════════════════
function triggerSub(time) {
  const v = computeVariation(state.drumSubVariation ?? 0);
  const d = computeDistance(state.drumSubDistance ?? 0.5);
  
  const { outGain: voiceOut, entry: voiceEntry } = acquireVoice('sub');
  const freq   = (state.drumSubFreq ?? 50) * v.vPitch;
  const level  = (state.drumSubLevel ?? 0.8) * 0.8 * v.vLevel * d.dLevel;
  const decay  = Math.min(MAX_DECAY_SEC, (state.drumSubDecay ?? 150) / 1000 * v.vDecay * d.dDecay);
  const tone   = (state.drumSubTone ?? 0.1) * d.dBright;
  const shape  = state.drumSubShape ?? 0;
  // Center: less drive saturation; Edge: more drive harmonics
  const drive  = clEd(state.drumSubDrive ?? 0, d.t, CL_ED.sub.drive);
  const subOct = state.drumSubSub ?? 0;
  const pitchEnvSt = state.drumSubPitchEnv ?? 0;
  const pitchDecay = Math.max(0.005, (state.drumSubPitchDecay ?? 50) / 1000);
  const attack = (state.drumSubAttack ?? 0) / 1000 * v.vAttack * d.dAttack;

  // Main oscillator — wave shape: 0=sine, 0.33=triangle, 0.66=sawtooth
  const osc = audioCtx.createOscillator();
  if (shape < 0.33)      osc.type = 'sine';
  else if (shape < 0.66) osc.type = 'triangle';
  else                    osc.type = 'sawtooth';

  // Pitch envelope
  osc.frequency.setValueAtTime(freq * Math.pow(2, pitchEnvSt / 12), time);
  osc.frequency.exponentialRampToValueAtTime(Math.max(20, freq), time + pitchDecay);

  // Drive (waveshaper saturation)
  let waveshaper = null;
  if (drive > 0.05) {
    waveshaper = audioCtx.createWaveShaper();
    waveshaper.curve = makeWaveshaperCurve(drive * 10);
    waveshaper.oversample = '2x';
  }

  // Main amp envelope with attack
  const gain = audioCtx.createGain();
  if (attack > 0.0005) {
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(level, time + attack);
    gain.gain.exponentialRampToValueAtTime(0.001, time + attack + decay);
  } else {
    gain.gain.setValueAtTime(level, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + decay);
  }
  const envDur = attack + decay;

  // Connect: osc → [waveshaper] → gain → master
  const _subNodes = [osc, gain];
  if (waveshaper) { osc.connect(waveshaper); waveshaper.connect(gain); _subNodes.push(waveshaper); }
  else            { osc.connect(gain); }
  gain.connect(voiceOut);
  osc.start(time);
  osc.stop(time + envDur + 0.02);
  let _subMaxDur = envDur + 0.02;

  // 2nd harmonic (tone)
  if (tone > 0.05) {
    const osc2 = audioCtx.createOscillator();
    osc2.type = 'sine';
    osc2.frequency.value = freq * 2;
    const g2 = audioCtx.createGain();
    if (attack > 0.0005) {
      g2.gain.setValueAtTime(0, time);
      g2.gain.linearRampToValueAtTime(tone * 0.3 * level, time + attack);
      g2.gain.exponentialRampToValueAtTime(0.001, time + attack + decay * 0.7);
    } else {
      g2.gain.setValueAtTime(tone * 0.3 * level, time);
      g2.gain.exponentialRampToValueAtTime(0.001, time + decay * 0.7);
    }
    osc2.connect(g2);
    g2.connect(voiceOut);
    osc2.start(time);
    osc2.stop(time + envDur + 0.02);
    _subNodes.push(osc2, g2);
  }

  // Sub-octave oscillator
  if (subOct > 0.05) {
    const subOsc = audioCtx.createOscillator();
    subOsc.type = 'sine';
    subOsc.frequency.value = freq / 2;
    const sg = audioCtx.createGain();
    const subDecay = Math.min(decay * 1.2, MAX_DECAY_SEC);
    if (attack > 0.0005) {
      sg.gain.setValueAtTime(0, time);
      sg.gain.linearRampToValueAtTime(subOct * 0.5 * level, time + attack);
      sg.gain.exponentialRampToValueAtTime(0.001, time + attack + subDecay);
    } else {
      sg.gain.setValueAtTime(subOct * 0.5 * level, time);
      sg.gain.exponentialRampToValueAtTime(0.001, time + subDecay);
    }
    subOsc.connect(sg);
    sg.connect(voiceOut);
    subOsc.start(time);
    const subStopDur = Math.min(envDur * 1.2 + 0.02, MAX_DECAY_SEC + attack + 0.02);
    subOsc.stop(time + subStopDur);
    _subNodes.push(subOsc, sg);
    _subMaxDur = Math.max(_subMaxDur, subStopDur);
  }
  voiceEntry.endTime = time + _subMaxDur;
}

// ════════════════════════════════════════════════════════════════
// Kick — matches drumSynth.ts: click transient, body, punch, tail, tone (waveshaper)
// ════════════════════════════════════════════════════════════════
function triggerKick(time) {
  const v = computeVariation(state.drumKickVariation ?? 0);
  const d = computeDistance(state.drumKickDistance ?? 0.5);
  
  const { outGain: voiceOut, entry: voiceEntry } = acquireVoice('kick');
  const baseFreq = (state.drumKickFreq ?? 55) * v.vPitch;
  const pitchEnvSt = state.drumKickPitchEnv ?? 24;
  // Center: pitch sweep extends; Edge: tighter sweep (capped at 0.5s to avoid laser effect)
  const pitchDecay = Math.min(0.5, clEd(Math.max(0.01, (state.drumKickPitchDecay ?? 30) / 1000), d.t, CL_ED.kick.pitchDecay));
  const decay  = Math.min(MAX_DECAY_SEC, (state.drumKickDecay ?? 200) / 1000 * v.vDecay * d.dDecay);
  const level  = (state.drumKickLevel ?? 0.7) * 0.9 * v.vLevel * d.dLevel;
  const click  = (state.drumKickClick ?? 0.3) * d.dTransient * v.vBright;
  // Center: more body resonance; Edge: thinner
  const body   = (state.drumKickBody ?? 0.5) * d.dBody;
  const punch  = (state.drumKickPunch ?? 0.5) * d.dTransient;
  // Center: more sub sustain tail; Edge: tighter
  const tail   = Math.max(0, clEd(state.drumKickTail ?? 0, d.t, CL_ED.kick.tail));
  const tone   = (state.drumKickTone ?? 0) * d.dBright;
  const attack = (state.drumKickAttack ?? 0) / 1000 * v.vAttack * d.dAttack;

  // Main sine oscillator with pitch sweep (punch affects pitch multiplier)
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  const punchMul = 0.5 + punch * 1.5;
  osc.frequency.setValueAtTime(baseFreq * Math.pow(2, (pitchEnvSt * punchMul) / 12), time);
  osc.frequency.exponentialRampToValueAtTime(Math.max(20, baseFreq), time + pitchDecay);

  // Tone → waveshaper distortion
  let waveshaper = null;
  if (tone > 0.05) {
    waveshaper = audioCtx.createWaveShaper();
    waveshaper.curve = makeWaveshaperCurve(tone * 5);
  }

  const gain = audioCtx.createGain();
  if (attack > 0.0005) {
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(level, time + attack);
    gain.gain.exponentialRampToValueAtTime(0.001, time + attack + decay);
  } else {
    gain.gain.setValueAtTime(level, time);
    gain.gain.exponentialRampToValueAtTime(0.001, time + decay);
  }
  const kickEnvDur = attack + decay;

  const _kickNodes = [osc, gain];
  if (waveshaper) { osc.connect(waveshaper); waveshaper.connect(gain); _kickNodes.push(waveshaper); }
  else            { osc.connect(gain); }
  gain.connect(voiceOut);
  osc.start(time);
  osc.stop(time + kickEnvDur + 0.02);
  let _kickMaxDur = kickEnvDur + 0.02;

  // Click transient (high-freq burst)
  if (click > 0.05) {
    const co = audioCtx.createOscillator();
    co.type = 'triangle';
    co.frequency.value = 3000 + punch * 2000;
    const cg = audioCtx.createGain();
    cg.gain.setValueAtTime(click * level * 0.5, time);
    cg.gain.exponentialRampToValueAtTime(0.001, time + 0.005);
    co.connect(cg);
    cg.connect(voiceOut);
    co.start(time);
    co.stop(time + 0.01);
    _kickNodes.push(co, cg);
  }

  // Body layer (mid-frequency triangle + lowpass)
  if (body > 0.1) {
    const bo = audioCtx.createOscillator();
    bo.type = 'triangle';
    bo.frequency.value = baseFreq * 1.5;
    const bf = audioCtx.createBiquadFilter();
    bf.type = 'lowpass';
    bf.frequency.value = baseFreq * 4;
    const bg = audioCtx.createGain();
    bg.gain.setValueAtTime(body * level * 0.4, time);
    bg.gain.exponentialRampToValueAtTime(0.001, time + decay * 0.6);
    bo.connect(bf);
    bf.connect(bg);
    bg.connect(voiceOut);
    bo.start(time);
    bo.stop(time + kickEnvDur + 0.02);
    _kickNodes.push(bo, bf, bg);
  }

  // Tail layer (filtered noise for room feel)
  if (tail > 0.1) {
    const ts = audioCtx.createBufferSource();
    ts.buffer = noiseBuffer;
    const tf = audioCtx.createBiquadFilter();
    tf.type = 'lowpass';
    tf.frequency.value = baseFreq * 2;
    tf.Q.value = 2;
    const tg = audioCtx.createGain();
    tg.gain.setValueAtTime(0, time);
    tg.gain.linearRampToValueAtTime(tail * level * 0.2, time + decay * 0.1);
    tg.gain.exponentialRampToValueAtTime(0.001, time + decay * 1.5);
    ts.connect(tf);
    tf.connect(tg);
    tg.connect(voiceOut);
    ts.start(time);
    ts.stop(time + kickEnvDur * 1.5 + 0.02);
    _kickNodes.push(ts, tf, tg);
    _kickMaxDur = Math.max(_kickMaxDur, kickEnvDur * 1.5 + 0.02);
  }
  voiceEntry.endTime = time + _kickMaxDur;
}

// ════════════════════════════════════════════════════════════════
// Click — matches drumSynth.ts: mode, exciterColor, pitch, pitchEnv, grains, stereo
// ════════════════════════════════════════════════════════════════
function triggerClick(time) {
  const v = computeVariation(state.drumClickVariation ?? 0);
  const d = computeDistance(state.drumClickDistance ?? 0.5);
  
  const { outGain: voiceOut, entry: voiceEntry } = acquireVoice('click');
  const decay      = Math.min(MAX_DECAY_SEC, (state.drumClickDecay ?? 5) / 1000 * v.vDecay * d.dDecay);
  const level      = (state.drumClickLevel ?? 0.6) * 0.8 * v.vLevel * d.dLevel;
  const filterFreq = (state.drumClickFilter ?? 4000) * v.vBright * d.dBright;
  // Center: more resonant ring, filter Q increases; Edge: dryer snap
  const resonance  = clEd((state.drumClickResonance ?? 0.4) * v.vBright, d.t, CL_ED.click.resonance);
  const tonePar    = (state.drumClickTone ?? 0.3) * d.dBright;
  const pitch      = (state.drumClickPitch ?? 2000) * v.vPitch;
  const pitchEnvSt = state.drumClickPitchEnv ?? 0;
  const mode       = state.drumClickMode ?? 'impulse';
  const grainCount = Math.round(state.drumClickGrainCount ?? 1);
  const grainSpread = (state.drumClickGrainSpread ?? 0) / 1000;
  const exciterColor = state.drumClickExciterColor ?? 0;
  const attack     = (state.drumClickAttack ?? 0) / 1000 * v.vAttack * d.dAttack;

  // Continuous exciter crossfade (overrides mode when active)
  if (exciterColor > 0.01 && mode !== 'granular') {
    const impLevel = Math.max(0, 1 - exciterColor * 2);
    const tonLevel = 1 - Math.abs(exciterColor - 0.5) * 2;
    const nzLevel  = Math.max(0, (exciterColor - 0.5) * 2);

    // Impulse component
    if (impLevel > 0.01) {
      const s = audioCtx.createBufferSource(); s.buffer = noiseBuffer;
      const f = audioCtx.createBiquadFilter(); f.type = 'highpass';
      f.frequency.value = filterFreq; f.Q.value = 0.5 + resonance * 15;
      const g = audioCtx.createGain();
      const d = decay * (0.1 + tonePar * 0.2);
      if (attack > 0.0005) { g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(level * impLevel, time + attack); g.gain.exponentialRampToValueAtTime(0.001, time + attack + d); }
      else { g.gain.setValueAtTime(level * impLevel, time); g.gain.exponentialRampToValueAtTime(0.001, time + d); }
      s.connect(f); f.connect(g); g.connect(voiceOut);
      s.start(time); s.stop(time + attack + d + 0.01);
    }
    // Tonal component
    if (tonLevel > 0.01) {
      const o = audioCtx.createOscillator(); o.type = 'sine';
      o.frequency.setValueAtTime(pitch * Math.pow(2, pitchEnvSt / 12), time);
      o.frequency.exponentialRampToValueAtTime(Math.max(20, pitch), time + decay * 0.3);
      const g = audioCtx.createGain();
      if (attack > 0.0005) { g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(level * tonLevel, time + attack); g.gain.exponentialRampToValueAtTime(0.001, time + attack + decay); }
      else { g.gain.setValueAtTime(level * tonLevel, time); g.gain.exponentialRampToValueAtTime(0.001, time + decay); }
      o.connect(g); g.connect(voiceOut);
      o.start(time); o.stop(time + attack + decay + 0.01);
    }
    // Noise component
    if (nzLevel > 0.01) {
      const s = audioCtx.createBufferSource(); s.buffer = noiseBuffer;
      const f = audioCtx.createBiquadFilter(); f.type = 'bandpass';
      f.frequency.value = filterFreq; f.Q.value = 1 + resonance * 10;
      const g = audioCtx.createGain();
      const d = decay * (0.5 + tonePar * 0.5);
      if (attack > 0.0005) { g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(level * nzLevel, time + attack); g.gain.exponentialRampToValueAtTime(0.001, time + attack + d); }
      else { g.gain.setValueAtTime(level * nzLevel, time); g.gain.exponentialRampToValueAtTime(0.001, time + d); }
      s.connect(f); f.connect(g); g.connect(voiceOut);
      s.start(time); s.stop(time + attack + d + 0.01);
    }
    voiceEntry.endTime = time + attack + decay + 0.02;
    return;
  }

  switch (mode) {
    case 'impulse': {
      const s = audioCtx.createBufferSource(); s.buffer = noiseBuffer;
      const f = audioCtx.createBiquadFilter(); f.type = 'highpass';
      f.frequency.value = filterFreq; f.Q.value = 0.5 + resonance * 15;
      const g = audioCtx.createGain();
      const d = decay * (0.1 + tonePar * 0.2);
      if (attack > 0.0005) { g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(level, time + attack); g.gain.exponentialRampToValueAtTime(0.001, time + attack + d); }
      else { g.gain.setValueAtTime(level, time); g.gain.exponentialRampToValueAtTime(0.001, time + d); }
      s.connect(f); f.connect(g); g.connect(voiceOut);
      s.start(time); s.stop(time + attack + d + 0.01);
      break;
    }
    case 'noise': {
      const s = audioCtx.createBufferSource(); s.buffer = noiseBuffer;
      const f = audioCtx.createBiquadFilter(); f.type = 'bandpass';
      f.frequency.value = filterFreq; f.Q.value = 1 + resonance * 10;
      const g = audioCtx.createGain();
      const d = decay * (0.5 + tonePar * 0.5);
      if (attack > 0.0005) { g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(level, time + attack); g.gain.exponentialRampToValueAtTime(0.001, time + attack + d); }
      else { g.gain.setValueAtTime(level, time); g.gain.exponentialRampToValueAtTime(0.001, time + d); }
      s.connect(f); f.connect(g); g.connect(voiceOut);
      s.start(time); s.stop(time + attack + d + 0.01);
      break;
    }
    case 'tonal': {
      const o = audioCtx.createOscillator(); o.type = 'sine';
      o.frequency.setValueAtTime(pitch * Math.pow(2, pitchEnvSt / 12), time);
      o.frequency.exponentialRampToValueAtTime(Math.max(20, pitch), time + decay * 0.3);
      const f = audioCtx.createBiquadFilter(); f.type = 'lowpass';
      f.frequency.value = filterFreq;
      const g = audioCtx.createGain();
      if (attack > 0.0005) { g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(level, time + attack); g.gain.exponentialRampToValueAtTime(0.001, time + attack + decay); }
      else { g.gain.setValueAtTime(level, time); g.gain.exponentialRampToValueAtTime(0.001, time + decay); }
      o.connect(f); f.connect(g); g.connect(voiceOut);
      o.start(time); o.stop(time + attack + decay + 0.01);
      break;
    }
    case 'granular': {
      const spread = grainSpread;
      const gLev = level / Math.sqrt(grainCount);
      const stereoWidth = state.drumClickStereoWidth ?? 0;
      for (let i = 0; i < grainCount; i++) {
        const gt = time + Math.random() * spread;
        const gd = decay * (0.5 + Math.random() * 0.5);
        const s = audioCtx.createBufferSource(); s.buffer = noiseBuffer;
        const f = audioCtx.createBiquadFilter(); f.type = 'highpass';
        f.frequency.value = filterFreq * (0.8 + Math.random() * 0.4); f.Q.value = 2;
        const g = audioCtx.createGain();
        if (attack > 0.0005) { g.gain.setValueAtTime(0, gt); g.gain.linearRampToValueAtTime(gLev, gt + attack); g.gain.exponentialRampToValueAtTime(0.001, gt + attack + gd); }
        else { g.gain.setValueAtTime(gLev, gt); g.gain.exponentialRampToValueAtTime(0.001, gt + gd); }
        s.connect(f); f.connect(g);
        // Stereo spread per grain (matching drumSynth.ts)
        if (stereoWidth > 0.01) {
          const panner = audioCtx.createStereoPanner();
          panner.pan.value = (Math.random() * 2 - 1) * stereoWidth;
          g.connect(panner); panner.connect(voiceOut);
        } else {
          g.connect(voiceOut);
        }
        s.start(gt); s.stop(gt + attack + gd + 0.01);
      }
      break;
    }
    default: {
      const s = audioCtx.createBufferSource(); s.buffer = noiseBuffer;
      const f = audioCtx.createBiquadFilter(); f.type = 'bandpass';
      f.frequency.value = filterFreq; f.Q.value = 0.8 + resonance * 10;
      const g = audioCtx.createGain();
      if (attack > 0.0005) { g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(level, time + attack); g.gain.exponentialRampToValueAtTime(0.001, time + attack + Math.max(0.005, decay)); }
      else { applyEnv(g, time, 0.0005, Math.max(0.005, decay), level); }
      s.connect(f); f.connect(g); g.connect(voiceOut);
      s.start(time); s.stop(time + attack + Math.max(0.02, decay + 0.01));
    }
  }
  voiceEntry.endTime = time + attack + decay + 0.02;
}

// ════════════════════════════════════════════════════════════════
// BeepHi — matches drumSynth.ts: partials + inharmonic, brightness, FM (tone, modRatio,
//   modRatioFine, modPhase, feedback, modEnvDecay, modEnvEnd, noiseInMod, noiseDecay), shimmer
// ════════════════════════════════════════════════════════════════
function triggerBeepHi(time) {
  const v = computeVariation(state.drumBeepHiVariation ?? 0);
  const d = computeDistance(state.drumBeepHiDistance ?? 0.5);

  const { outGain: voiceOut, entry: voiceEntry } = acquireVoice('beepHi');

  // BeepHi: metallic sounds get brighter at center (more ring + harmonics)
  // unlike generic dBright which darkens at center
  const dBrightHi = clEd(1, d.t, CL_ED.beepHi.bright);  // center=1.6, edge=1.4
  const dLevelHi  = d.dLevel * d.dBody;                 // thinner at edge
  const dAttackHi = d.dAttack;
  const freq       = (state.drumBeepHiFreq ?? 4000) * v.vPitch;
  const attack     = (state.drumBeepHiAttack ?? 1) / 1000 * v.vAttack * dAttackHi;
  const decay      = Math.min(MAX_DECAY_SEC, (state.drumBeepHiDecay ?? 80) / 1000 * v.vDecay * d.dDecay);
  const level      = (state.drumBeepHiLevel ?? 0.5) * 0.7 * v.vLevel * dLevelHi;
  const tone       = (state.drumBeepHiTone ?? 0.2) * dBrightHi;
  const inharmonic = state.drumBeepHiInharmonic ?? 0;
  const partials   = Math.max(1, Math.round(state.drumBeepHiPartials ?? 1));
  const brightness = (state.drumBeepHiBrightness ?? 0.5) * dBrightHi;
  // Center: longer shimmer, more shimmer depth
  const shimmer    = clEd(state.drumBeepHiShimmer ?? 0, d.t, CL_ED.beepHi.shimmer);
  const shimmerRate = (state.drumBeepHiShimmerRate ?? 4) * v.vBright;
  const modRatioCoarse = state.drumBeepHiModRatio ?? 2;
  const modRatioFine = state.drumBeepHiModRatioFine ?? 0.01;
  const modRatio   = modRatioCoarse + modRatioFine;
  const modPhase   = state.drumBeepHiModPhase ?? 0;
  // Center: FM feedback increases for richer harmonics
  const feedback   = Math.min(1, Math.max(-1, clEd(state.drumBeepHiFeedback ?? 0, d.t, CL_ED.beepHi.feedback)));
  const modEnvDecay = state.drumBeepHiModEnvDecay ?? 0;
  const modEnvEnd  = state.drumBeepHiModEnvEnd ?? 0.2;
  const noiseInMod = state.drumBeepHiNoiseInMod ?? 0;
  const noiseDecay = state.drumBeepHiNoiseDecay ?? 0;
  const endT       = time + attack + decay + 0.02;

  // Brightness lowpass
  const bpf = audioCtx.createBiquadFilter();
  bpf.type = 'lowpass';
  bpf.frequency.value = freq * (1 + brightness * 4);

  // Main gain
  const mainGain = audioCtx.createGain();
  bpf.connect(mainGain);
  mainGain.connect(voiceOut);

  // Shimmer LFO
  if (shimmer > 0.01) {
    const lfo = audioCtx.createOscillator();
    lfo.type = 'sine'; lfo.frequency.value = shimmerRate;
    const lg = audioCtx.createGain();
    lg.gain.value = shimmer * 0.3 * level;
    lfo.connect(lg); lg.connect(mainGain.gain);
    lfo.start(time); lfo.stop(endT);
  }

  // Create partials
  const oscs = [];
  for (let i = 0; i < partials; i++) {
    const harmRatio = i + 1;
    const inOffset = Math.pow(harmRatio, 1 + inharmonic * 0.5) - harmRatio;
    const pFreq = freq * (harmRatio + inOffset * inharmonic);
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = pFreq;
    const g = audioCtx.createGain();
    const pLev = level / partials / Math.pow(harmRatio, 0.5);
    g.gain.setValueAtTime(0, time);
    g.gain.linearRampToValueAtTime(pLev, time + attack);
    g.gain.exponentialRampToValueAtTime(0.001, time + attack + decay);
    osc.connect(g); g.connect(bpf);
    osc.start(time); osc.stop(endT);
    oscs.push(osc);
  }

  // FM modulation (tone > 0.1)
  if (tone > 0.1 && oscs.length > 0) {
    const modOsc = audioCtx.createOscillator();
    // Mod phase: apply start phase offset via PeriodicWave (matching drumSynth.ts)
    if (modPhase > 0.001) {
      const phi = modPhase * 2 * Math.PI;
      const real = new Float32Array([0, Math.sin(phi)]);
      const imag = new Float32Array([0, Math.cos(phi)]);
      const wave = audioCtx.createPeriodicWave(real, imag, { disableNormalization: false });
      modOsc.setPeriodicWave(wave);
    } else {
      modOsc.type = 'sine';
    }
    modOsc.frequency.value = freq * Math.max(0.1, modRatio);
    const baseDepth = tone * freq * 0.3;

    // FM feedback
    if (Math.abs(feedback) > 0.01) {
      const fbDelay = audioCtx.createDelay(0.01);
      fbDelay.delayTime.value = 1 / (freq * modRatio);
      const fbGain = audioCtx.createGain();
      fbGain.gain.value = feedback * freq * 0.5;
      modOsc.connect(fbDelay);
      fbDelay.connect(fbGain);
      fbGain.connect(modOsc.frequency);
    }

    // Mod envelope vs static
    if (modEnvDecay > 0.01) {
      const envDur = 0.005 + modEnvDecay * 0.295;
      const peakMod = baseDepth * (1 + modEnvDecay * 4);
      const sustMod = Math.max(baseDepth * modEnvEnd, 0.01);
      const meg = audioCtx.createGain();
      meg.gain.setValueAtTime(peakMod, time);
      meg.gain.exponentialRampToValueAtTime(sustMod, time + envDur);
      modOsc.connect(meg);
      meg.connect(oscs[0].frequency);
    } else {
      const mg = audioCtx.createGain();
      mg.gain.value = baseDepth;
      modOsc.connect(mg);
      mg.connect(oscs[0].frequency);
    }
    modOsc.start(time); modOsc.stop(endT);

    // Noise injection into FM path
    if (noiseInMod > 0.01) {
      const nb = audioCtx.createBuffer(1, Math.ceil(audioCtx.sampleRate * 0.05), audioCtx.sampleRate);
      const nd = nb.getChannelData(0);
      for (let i = 0; i < nd.length; i++) nd[i] = Math.random() * 2 - 1;
      const ns = audioCtx.createBufferSource(); ns.buffer = nb;
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(noiseInMod * freq * 0.5, time);
      const nDur = 0.005 + noiseDecay * (attack + decay * 0.8);
      ng.gain.exponentialRampToValueAtTime(0.01, time + nDur);
      ns.connect(ng); ng.connect(oscs[0].frequency);
      ns.start(time); ns.stop(endT);
    }
  }
  voiceEntry.endTime = endT;
}

// ════════════════════════════════════════════════════════════════
// BeepLo — matches drumSynth.ts: tone (sine↔square), pitchEnv, body resonance,
//   pluck (Karplus-Strong), modal resonator bank (modal, modalQ, inharmonic, spread, cut)
// ════════════════════════════════════════════════════════════════
function triggerBeepLo(time) {
  const v = computeVariation(state.drumBeepLoVariation ?? 0);
  const d = computeDistance(state.drumBeepLoDistance ?? 0.5);
  
  const { outGain: voiceOut, entry: voiceEntry } = acquireVoice('beepLo');
  const freq       = (state.drumBeepLoFreq ?? 400) * v.vPitch;
  const attack     = (state.drumBeepLoAttack ?? 2) / 1000 * v.vAttack * d.dAttack;
  const decay      = Math.min(MAX_DECAY_SEC, (state.drumBeepLoDecay ?? 100) / 1000 * v.vDecay * d.dDecay);
  const level      = (state.drumBeepLoLevel ?? 0.5) * 0.8 * v.vLevel * d.dLevel;
  const tone       = (state.drumBeepLoTone ?? 0.1) * d.dBright;
  // Center: body resonance up; Edge: thinner
  const body       = (state.drumBeepLoBody ?? 0.3) * d.dBody;
  const pitchEnvSt = state.drumBeepLoPitchEnv ?? 0;
  const pitchDecay = Math.max(0.005, (state.drumBeepLoPitchDecay ?? 50) / 1000);
  const pluck      = state.drumBeepLoPluck ?? 0;
  const pluckDamp  = Math.max(0, Math.min(1, (state.drumBeepLoPluckDamp ?? 0.5) + (d.dBright - 1) * 0.3));
  const modal      = state.drumBeepLoModal ?? 0;
  // Center: more harmonics from modal bank (higher Q); Edge: less modal energy
  const modalQ     = clEd(state.drumBeepLoModalQ ?? 10, d.t, CL_ED.beepLo.modalQ);
  const modalInharm = state.drumBeepLoModalInharmonic ?? 0;
  const modalSpread = state.drumBeepLoModalSpread ?? 0;
  const modalCut   = state.drumBeepLoModalCut ?? 0;
  const oscGainTrim = state.drumBeepLoOscGain ?? 1;
  // Center: more modal gain for richer partials
  const modalGainTrim = clEd(state.drumBeepLoModalGain ?? 1, d.t, CL_ED.beepLo.modalGain);
  const exciteJitter = v.vExcite;
  const brightnessMult = d.dBright;
  const endT       = time + attack + decay + 0.02;

  // Equal-power crossfade between osc/pluck and modal resonator.
  // At modal=0: 100% osc. At modal=0.5: equal power (~0.707 each). At modal=1: 100% modal.
  const oscAmp = Math.cos(modal * Math.PI / 2) * oscGainTrim;
  const modalAmp = Math.sin(modal * Math.PI / 2) * modalGainTrim;

  // ── Modal resonator bank (when modal > 0) ──
  if (modalAmp > 0.01) {
    const modalLevel = level * modalAmp;
    const numModes = 6;
    const gOut = audioCtx.createGain();
    // Modal synthesis: impulse-excited, no attack ramp. Start at peak, decay.
    gOut.gain.setValueAtTime(modalLevel, time);
    gOut.gain.exponentialRampToValueAtTime(0.001, time + decay);
    gOut.connect(voiceOut);
    // Noise burst excitation — boosted, with exciteJitter scaling burst length
    const exciteBoost = 40;
    const burstLength = 0.005 * exciteJitter;
    const eBuf = audioCtx.createBuffer(1, Math.ceil(audioCtx.sampleRate * burstLength), audioCtx.sampleRate);
    const eD = eBuf.getChannelData(0);
    for (let i = 0; i < eD.length; i++) eD[i] = (Math.random() * 2 - 1) * (1 - i / eD.length) * exciteBoost;
    const eSrc = audioCtx.createBufferSource(); eSrc.buffer = eBuf;
    const harmRatios = [1, 2, 3, 4, 5, 6];
    const bellRatios = [1, 2.0, 3.0, 4.2, 5.4, 6.8];
    for (let i = 0; i < numModes; i++) {
      let ratio = harmRatios[i] + (bellRatios[i] - harmRatios[i]) * modalInharm;
      if (Math.abs(modalSpread) > 0.01) {
        const norm = ratio / harmRatios[numModes - 1];
        ratio = modalSpread > 0
          ? harmRatios[numModes - 1] * Math.pow(norm, 1 - modalSpread * 0.7)
          : harmRatios[numModes - 1] * Math.pow(norm, 1 + Math.abs(modalSpread) * 2);
        ratio = Math.max(ratio, 0.5);
      }
      const mf = Math.min(freq * ratio, 18000);
      const res = audioCtx.createBiquadFilter();
      res.type = 'bandpass'; res.frequency.value = mf;
      // brightnessMult shapes upper mode Q (center=darker, edge=brighter/more resonant)
      const modeQScale = i === 0 ? 1 : brightnessMult;
      res.Q.value = modalQ * (1 - i * 0.1) * modeQScale;
      const mg = audioCtx.createGain();
      // brightnessMult shapes upper mode amplitudes (center=attenuated, edge=boosted)
      const brightAtten = i === 0 ? 1 : Math.pow(brightnessMult, 0.5 + i * 0.3);
      let mLev = brightAtten / (numModes * Math.pow(i + 1, 0.3 + body * 0.5));
      if (Math.abs(modalCut) > 0.01) {
        const ni = i / (numModes - 1);
        mLev *= modalCut > 0 ? Math.pow(ni, modalCut * 1.5) : Math.pow(1 - ni, Math.abs(modalCut) * 1.5);
      }
      mg.gain.value = mLev;
      eSrc.connect(res); res.connect(mg); mg.connect(gOut);
    }
    eSrc.start(time); eSrc.stop(time + burstLength + 0.001);
  }

  // ── Oscillator / Pluck engine (when modal < 1) ──
  if (oscAmp < 0.01) { voiceEntry.endTime = endT; return; } // fully modal, skip osc path
  const oscLevel = level * oscAmp;

  // Pluck (Karplus-Strong approximation, if pluck > 0.3)
  if (pluck > 0.3) {
    const src = audioCtx.createBufferSource(); src.buffer = noiseBuffer;
    const eg = audioCtx.createGain();
    eg.gain.setValueAtTime(oscLevel * pluck, time);
    eg.gain.exponentialRampToValueAtTime(0.001, time + 0.005);
    const bf = audioCtx.createBiquadFilter();
    bf.type = 'bandpass'; bf.frequency.value = freq; bf.Q.value = 50 + body * 150;
    const df = audioCtx.createBiquadFilter();
    df.type = 'lowpass'; df.frequency.value = freq * (2 + (1 - pluckDamp) * 4);
    const og = audioCtx.createGain();
    og.gain.setValueAtTime(oscLevel, time);
    og.gain.exponentialRampToValueAtTime(0.001, time + decay);
    src.connect(eg); eg.connect(bf); bf.connect(df); df.connect(og); og.connect(voiceOut);
    src.start(time); src.stop(time + 0.015);
    // Sine reinforcement
    const po = audioCtx.createOscillator(); po.type = 'sine'; po.frequency.value = freq;
    const pg = audioCtx.createGain();
    pg.gain.setValueAtTime(oscLevel * (1 - pluck) * 0.5, time);
    pg.gain.exponentialRampToValueAtTime(0.001, time + decay);
    po.connect(pg); pg.connect(voiceOut);
    po.start(time); po.stop(endT);
    voiceEntry.endTime = endT;
    return;
  }

  // Standard oscillator mode
  const osc = audioCtx.createOscillator();
  osc.type = tone > 0.5 ? 'square' : 'sine';
  osc.frequency.setValueAtTime(freq * Math.pow(2, pitchEnvSt / 12), time);
  osc.frequency.exponentialRampToValueAtTime(Math.max(20, freq), time + pitchDecay);

  let lastNode = osc;
  // Lowpass if square wave
  if (tone > 0.5) {
    const lp = audioCtx.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.value = freq * 4; lp.Q.value = 0.7;
    osc.connect(lp); lastNode = lp;
  }
  // Body resonance (peaking EQ)
  if (body > 0.1) {
    const bf = audioCtx.createBiquadFilter();
    bf.type = 'peaking'; bf.frequency.value = freq * 1.5;
    bf.Q.value = 2 + body * 5; bf.gain.value = body * 6;
    lastNode.connect(bf); lastNode = bf;
  }
  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0, time);
  g.gain.linearRampToValueAtTime(oscLevel, time + attack);
  g.gain.exponentialRampToValueAtTime(0.001, endT);
  lastNode.connect(g); g.connect(voiceOut);
  osc.start(time); osc.stop(endT);
  voiceEntry.endTime = endT;
}

// ════════════════════════════════════════════════════════════════
// Noise — matches drumSynth.ts: filterEnv, formant, breath, colorLFO,
//   density/particle, ratchet
// ════════════════════════════════════════════════════════════════
function triggerNoise(time) {
  const v = computeVariation(state.drumNoiseVariation ?? 0);
  const d = computeDistance(state.drumNoiseDistance ?? 0.5);
  
  const { outGain: voiceOut, entry: voiceEntry } = acquireVoice('noise');
  const attack       = (state.drumNoiseAttack ?? 0) / 1000 * v.vAttack * d.dAttack;
  const decay        = Math.min(MAX_DECAY_SEC, (state.drumNoiseDecay ?? 30) / 1000 * v.vDecay * d.dDecay);
  const level        = (state.drumNoiseLevel ?? 0.4) * 0.8 * v.vLevel * d.dLevel;
  // Noise: center = filter OPENS (wash), edge = filter closes (darker burst)
  // Inverted from generic dBright because noise wash spreads at center
  const noiseBright  = clEd(1, d.t, CL_ED.noise.bright);
  const filterFreq   = Math.max(20, Math.min(20000, (state.drumNoiseFilterFreq ?? 8000) * v.vBright * noiseBright));
  const filterQ      = (state.drumNoiseFilterQ ?? 1) * v.vBright;
  const filterType   = state.drumNoiseFilterType ?? 'highpass';
  const filterEnv    = state.drumNoiseFilterEnv ?? 0;
  const filterEnvDec = Math.max(0.005, (state.drumNoiseFilterEnvDecay ?? 100) / 1000);
  // Center: formant resonance increases
  const formant      = clEd(state.drumNoiseFormant ?? 0, d.t, CL_ED.noise.formant);
  const breath       = state.drumNoiseBreath ?? 0;
  const colorLFO     = state.drumNoiseColorLFO ?? 0;
  // Center: sustained wash (full density); Edge: short burst (sparser)
  const density      = clEd(state.drumNoiseDensity ?? 1, d.t, CL_ED.noise.density);
  const particleSize = Math.max(0.001, (state.drumNoiseParticleSize ?? 5) / 1000);
  const particleRandom = state.drumNoiseParticleRandom ?? 0;
  const particleRandomRate = state.drumNoiseParticleRandomRate ?? 0.5;
  const ratchetCount = Math.round(state.drumNoiseRatchetCount ?? 0);
  const ratchetTime  = (state.drumNoiseRatchetTime ?? 30) / 1000;

  // Ratchet pre-hits
  if (ratchetCount > 0) {
    for (let r = 0; r < ratchetCount; r++) {
      const rt = time + r * ratchetTime;
      const rl = level * Math.pow(0.65, ratchetCount - r);
      const rd = Math.min(ratchetTime * 0.8, 0.03);
      const rs = audioCtx.createBufferSource(); rs.buffer = noiseBuffer; rs.loop = true;
      const rf = audioCtx.createBiquadFilter(); rf.type = filterType;
      rf.frequency.value = filterFreq; rf.Q.value = filterQ;
      const rg = audioCtx.createGain();
      rg.gain.setValueAtTime(0, rt);
      rg.gain.linearRampToValueAtTime(rl, rt + 0.001);
      rg.gain.exponentialRampToValueAtTime(0.001, rt + rd);
      rs.connect(rf); rf.connect(rg); rg.connect(voiceOut);
      rs.start(rt); rs.stop(rt + rd + 0.002);
    }
  }

  // Main hit (offset by ratchet)
  const mainT = ratchetCount > 0 ? time + ratchetCount * ratchetTime : time;
  const endT  = mainT + attack + decay + 0.02;

  const src = audioCtx.createBufferSource();
  src.buffer = noiseBuffer; src.loop = true;

  // Main filter with envelope
  const mf = audioCtx.createBiquadFilter();
  mf.type = filterType; mf.Q.value = filterQ;
  const envAmt = filterEnv * filterFreq;
  const startFFreq = Math.max(20, Math.min(20000, filterFreq + envAmt));
  mf.frequency.setValueAtTime(startFFreq, mainT);
  mf.frequency.exponentialRampToValueAtTime(Math.max(20, filterFreq), mainT + filterEnvDec);

  // Output gain with amplitude envelope
  const outGain = audioCtx.createGain();
  outGain.gain.setValueAtTime(0, mainT);
  outGain.gain.linearRampToValueAtTime(level, mainT + attack);
  outGain.gain.exponentialRampToValueAtTime(0.001, endT);

  src.connect(mf); mf.connect(outGain);

  // Formant bank (vowel resonances)
  if (formant > 0.05) {
    const fmGain = audioCtx.createGain();
    fmGain.gain.value = formant;
    [700, 1200, 2500].map(f => Math.min(20000, f * d.dBright)).forEach(fFreq => {
      const ff = audioCtx.createBiquadFilter();
      ff.type = 'bandpass'; ff.frequency.value = fFreq;
      ff.Q.value = 5 + formant * 10;
      src.connect(ff);
      const fmg = audioCtx.createGain();
      fmg.gain.value = 1 / 3;
      ff.connect(fmg); fmg.connect(fmGain);
    });
    fmGain.connect(outGain);
  }

  // Breath LFO (amplitude modulation)
  if (breath > 0.05) {
    const bLfo = audioCtx.createOscillator();
    bLfo.type = 'sine'; bLfo.frequency.value = 8 + Math.random() * 4;
    const bg = audioCtx.createGain();
    bg.gain.value = breath * 0.3 * level;
    bLfo.connect(bg); bg.connect(outGain.gain);
    bLfo.start(mainT); bLfo.stop(endT);
  }

  // Color LFO (filter freq modulation)
  if (colorLFO > 0.01) {
    const cLfo = audioCtx.createOscillator();
    cLfo.type = 'sine'; cLfo.frequency.value = colorLFO;
    const cg = audioCtx.createGain();
    cg.gain.value = filterFreq * 0.3;
    cLfo.connect(cg); cg.connect(mf.frequency);
    cLfo.start(mainT); cLfo.stop(endT);
  }

  outGain.connect(voiceOut);

  // ── Density / Particle system (Opal-inspired) ──
  if (density < 0.9) {
    if (density < 0.4) {
      // Pulsar particle mode: replace continuous noise with Hann-windowed grains
      const totalDuration = attack + decay;
      const numGrains = Math.max(1, Math.round(density * 40 * totalDuration / particleSize));
      // Disconnect continuous source from filter (we'll use per-grain buffers)
      mf.disconnect();

      const randResetInterval = particleRandomRate > 0.01 ? (1.0 - particleRandomRate) * 0.5 + 0.01 : 999;
      let lastRandPitch = 1.0;
      let lastRandTime = 0;

      for (let g = 0; g < numGrains; g++) {
        let grainDuration = particleSize;
        if (particleRandom > 0.01) {
          const grainProgress = g / numGrains;
          if (grainProgress - lastRandTime >= randResetInterval || g === 0) {
            lastRandPitch = 1.0 + (Math.random() * 2 - 1) * particleRandom * 0.5;
            lastRandTime = grainProgress;
          }
          grainDuration = particleSize * (1 + (Math.random() * 2 - 1) * particleRandom * 0.3);
          grainDuration = Math.max(0.001, grainDuration);
        }

        // Hann-windowed noise grain
        const grainBuf = audioCtx.createBuffer(1, Math.ceil(audioCtx.sampleRate * grainDuration), audioCtx.sampleRate);
        const gd = grainBuf.getChannelData(0);
        for (let i = 0; i < gd.length; i++) {
          const t = i / gd.length;
          const win = 0.5 * (1 - Math.cos(2 * Math.PI * t));
          gd[i] = (Math.random() * 2 - 1) * win;
        }

        const baseTime = mainT + (g / numGrains) * totalDuration;
        const timeJitter = particleRandom > 0.01
          ? (Math.random() * 2 - 1) * particleRandom * grainDuration * 2
          : Math.random() * grainDuration;
        const grainTime = Math.max(mainT, Math.min(baseTime + timeJitter, mainT + totalDuration - grainDuration));

        const grain = audioCtx.createBufferSource();
        grain.buffer = grainBuf;
        if (particleRandom > 0.01) grain.playbackRate.value = lastRandPitch;

        const gGain = audioCtx.createGain();
        // Follow main amplitude envelope
        const envPos = (grainTime - mainT) / totalDuration;
        const envLevel = envPos < (attack / totalDuration)
          ? envPos / (attack / totalDuration) * level
          : level * Math.exp(-3 * (envPos - attack / totalDuration));
        gGain.gain.value = envLevel;

        grain.connect(mf);
        mf.connect(gGain);
        gGain.connect(voiceOut);
        grain.start(grainTime);
        grain.stop(grainTime + grainDuration + 0.001);
      }
    } else {
      // Medium density (0.4-0.9): square-wave gating
      const sparseGain = audioCtx.createGain();
      const sparseOsc = audioCtx.createOscillator();
      sparseOsc.type = 'square';
      sparseOsc.frequency.value = 20 + density * 80;
      const sparseOscGain = audioCtx.createGain();
      sparseOscGain.gain.value = 0.5;
      sparseOsc.connect(sparseOscGain);
      sparseOscGain.connect(sparseGain.gain);
      sparseGain.gain.value = 0.5;
      // Re-route: filter → gating → output
      mf.disconnect();
      mf.connect(sparseGain);
      sparseGain.connect(outGain);
      sparseOsc.start(mainT);
      sparseOsc.stop(endT + 0.01);
    }
  }

  src.start(mainT); src.stop(endT);
  voiceEntry.endTime = endT;
}

// ════════════════════════════════════════════════════════════════
// Membrane — physical-modeling drum: crossed delay lines (membrane modes)
// + optional wire buzz circuit (snare wires / rattles)
// ════════════════════════════════════════════════════════════════
function triggerMembrane(time) {
  const v = computeVariation(state.drumMembraneVariation ?? 0);
  const d = computeDistance(state.drumMembraneDistance ?? 0.5);

  const { outGain: voiceOut, entry: voiceEntry } = acquireVoice('membrane');

  const excType   = state.drumMembraneExciter ?? 'impulse';
  const excPos    = state.drumMembraneExcPos ?? 0.3;
  const excBright = (state.drumMembraneExcBright ?? 0.5) * v.vBright * d.dBright;
  const excDur    = Math.max(0.0005, (state.drumMembraneExcDur ?? 3) / 1000);
  const size      = (state.drumMembraneSize ?? 180) * v.vPitch;
  // Center: tension increases → brighter overtones, longer ring
  const tension   = Math.min(1, clEd(state.drumMembraneTension ?? 0.5, d.t, CL_ED.membrane.tension));
  const damping   = state.drumMembraneDamping ?? 0.3;
  const material  = state.drumMembraneMaterial ?? 'skin';
  const nonlin    = state.drumMembraneNonlin ?? 0;
  // Center: more wire buzz sustain; Edge: less wire (dead slap)
  const wireMix   = Math.max(0, clEd(state.drumMembraneWireMix ?? 0, d.t, CL_ED.membrane.wireMix));
  const wireDens  = state.drumMembraneWireDensity ?? 0.5;
  const wireTone  = state.drumMembraneWireTone ?? 0.5;
  // Center: longer wire sustain
  const wireDecay = Math.min(1, clEd(state.drumMembraneWireDecay ?? 0.5, d.t, CL_ED.membrane.wireDecay));
  const body      = state.drumMembraneBody ?? 0.5;
  const ring      = state.drumMembraneRing ?? 0.2;
  const overtones = Math.round(state.drumMembraneOvertones ?? 4);
  const pitchEnvSt = state.drumMembranePitchEnv ?? 3;
  const pitchDecay = Math.max(0.005, (state.drumMembranePitchDecay ?? 40) / 1000);
  const attack    = (state.drumMembraneAttack ?? 0) / 1000 * v.vAttack * d.dAttack;
  const decay     = Math.min(MAX_DECAY_SEC, (state.drumMembraneDecay ?? 250) / 1000 * v.vDecay * d.dDecay);
  const level     = (state.drumMembraneLevel ?? 0.6) * 0.8 * v.vLevel * d.dLevel;

  // Material affects inharmonicity & damping character
  const materialMod = { skin: { inharm: 0, damp: 1.0, bright: 1.0 },
    metal: { inharm: 0.3, damp: 0.5, bright: 1.5 },
    wood:  { inharm: 0.15, damp: 1.3, bright: 0.7 },
    glass: { inharm: 0.4, damp: 0.3, bright: 2.0 },
    plastic: { inharm: 0.1, damp: 0.8, bright: 1.2 } }[material] || { inharm: 0, damp: 1.0, bright: 1.0 };

  const envDur = attack + decay;
  const masterOut = audioCtx.createGain();
  masterOut.gain.value = 1.0;
  masterOut.connect(voiceOut);

  // ── Exciter signal ──
  const excGain = audioCtx.createGain();
  excGain.gain.setValueAtTime(level * (0.5 + excBright * 0.5), time);
  excGain.gain.exponentialRampToValueAtTime(0.001, time + excDur);

  if (excType === 'noise' || excType === 'brush') {
    const src = audioCtx.createBufferSource();
    src.buffer = noiseBuffer; src.loop = false;
    const ef = audioCtx.createBiquadFilter();
    ef.type = 'lowpass';
    ef.frequency.value = 2000 + excBright * 12000;
    if (excType === 'brush') { ef.frequency.value *= 0.6; ef.Q.value = 2; }
    src.connect(ef); ef.connect(excGain);
    src.start(time); src.stop(time + excDur + 0.01);
  } else if (excType === 'mallet') {
    // Soft sine burst (low-pass character)
    const osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = size * 2;
    osc.connect(excGain);
    osc.start(time); osc.stop(time + excDur + 0.01);
  } else if (excType === 'stick') {
    // Short bright click
    const osc = audioCtx.createOscillator();
    osc.type = 'triangle';
    osc.frequency.value = 3000 + excBright * 5000;
    osc.connect(excGain);
    osc.start(time); osc.stop(time + excDur + 0.01);
    // Plus noise click
    const ns = audioCtx.createBufferSource();
    ns.buffer = noiseBuffer;
    const ng = audioCtx.createGain();
    ng.gain.setValueAtTime(level * 0.3, time);
    ng.gain.exponentialRampToValueAtTime(0.001, time + Math.min(excDur, 0.003));
    ns.connect(ng); ng.connect(excGain);
    ns.start(time); ns.stop(time + 0.005);
  } else {
    // impulse (default) — single-sample-ish click via very short noise
    const src = audioCtx.createBufferSource();
    src.buffer = noiseBuffer;
    const hpf = audioCtx.createBiquadFilter();
    hpf.type = 'highpass';
    hpf.frequency.value = 1000 + excBright * 8000;
    src.connect(hpf); hpf.connect(excGain);
    src.start(time); src.stop(time + excDur + 0.01);
  }

  // ── Membrane modes (bank of resonant bandpass filters simulating circular membrane) ──
  // Circular membrane mode ratios: 1.00, 1.59, 2.14, 2.30, 2.65, 2.92, 3.16, 3.50
  const modeRatios = [1.0, 1.59, 2.14, 2.30, 2.65, 2.92, 3.16, 3.50];
  const numModes = Math.min(overtones, modeRatios.length);
  const inharm = materialMod.inharm + nonlin * 0.2;

  for (let m = 0; m < numModes; m++) {
    const ratio = modeRatios[m] + inharm * (m * 0.08) * (Math.random() * 0.4 + 0.8);
    // Position affects which modes are excited (center excites odd modes more)
    const posAmp = m === 0 ? 1.0 : (1.0 - Math.abs(excPos - 0.5) * (m % 2 === 0 ? 1.5 : 0.3));
    const modeFreq = size * ratio * (0.5 + tension * 1.0);
    const modeQ = (5 + ring * 40 + (1 - damping) * 30) * materialMod.damp / (1 + m * 0.3);
    const modeLevel = level * Math.max(0.05, posAmp) * body / (1 + m * 0.4) * materialMod.bright;

    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.setValueAtTime(modeFreq * Math.pow(2, pitchEnvSt / 12), time);
    bp.frequency.exponentialRampToValueAtTime(Math.max(20, modeFreq), time + pitchDecay);
    bp.Q.value = Math.max(1, modeQ);

    const mGain = audioCtx.createGain();
    if (attack > 0.0005) {
      mGain.gain.setValueAtTime(0, time);
      mGain.gain.linearRampToValueAtTime(modeLevel, time + attack);
      mGain.gain.exponentialRampToValueAtTime(0.001, time + attack + decay / (1 + m * 0.15));
    } else {
      mGain.gain.setValueAtTime(modeLevel, time);
      mGain.gain.exponentialRampToValueAtTime(0.001, time + decay / (1 + m * 0.15));
    }

    excGain.connect(bp);
    bp.connect(mGain);
    mGain.connect(masterOut);
  }

  // ── Fundamental oscillator for body ──
  if (body > 0.1) {
    const bodyOsc = audioCtx.createOscillator();
    bodyOsc.type = 'sine';
    bodyOsc.frequency.setValueAtTime(size * Math.pow(2, pitchEnvSt / 12), time);
    bodyOsc.frequency.exponentialRampToValueAtTime(Math.max(20, size), time + pitchDecay);
    const bodyGain = audioCtx.createGain();
    if (attack > 0.0005) {
      bodyGain.gain.setValueAtTime(0, time);
      bodyGain.gain.linearRampToValueAtTime(level * body * 0.4, time + attack);
      bodyGain.gain.exponentialRampToValueAtTime(0.001, time + attack + decay);
    } else {
      bodyGain.gain.setValueAtTime(level * body * 0.4, time);
      bodyGain.gain.exponentialRampToValueAtTime(0.001, time + decay);
    }
    bodyOsc.connect(bodyGain);
    bodyGain.connect(masterOut);
    bodyOsc.start(time);
    bodyOsc.stop(time + envDur + 0.05);
  }

  // ── Wire Buzz (snare wires / rattle simulation) ──
  if (wireMix > 0.01) {
    const wireNoise = audioCtx.createBufferSource();
    wireNoise.buffer = noiseBuffer; wireNoise.loop = true;

    // High-pass + bandpass to shape wire spectrum
    const wireHP = audioCtx.createBiquadFilter();
    wireHP.type = 'highpass';
    wireHP.frequency.value = 1500 + wireTone * 4000;

    const wireBP = audioCtx.createBiquadFilter();
    wireBP.type = 'bandpass';
    wireBP.frequency.value = 3000 + wireTone * 6000;
    wireBP.Q.value = 1 + wireDens * 4;

    // Modulate wire amplitude to simulate sympathetic buzzing
    const wireAmpGain = audioCtx.createGain();
    const wireLevel = level * wireMix * 0.5;
    const wireDec = decay * (0.3 + wireDecay * 1.4);
    if (attack > 0.0005) {
      wireAmpGain.gain.setValueAtTime(0, time);
      wireAmpGain.gain.linearRampToValueAtTime(wireLevel, time + attack + 0.002);
      wireAmpGain.gain.exponentialRampToValueAtTime(0.001, time + attack + wireDec);
    } else {
      wireAmpGain.gain.setValueAtTime(wireLevel, time + 0.001);
      wireAmpGain.gain.exponentialRampToValueAtTime(0.001, time + wireDec);
    }

    // Density: add AM modulation to create rattle texture
    if (wireDens > 0.3) {
      const rattleLfo = audioCtx.createOscillator();
      rattleLfo.type = 'square';
      rattleLfo.frequency.value = 100 + wireDens * 400;
      const rattleDepth = audioCtx.createGain();
      rattleDepth.gain.value = wireLevel * wireDens * 0.3;
      rattleLfo.connect(rattleDepth);
      rattleDepth.connect(wireAmpGain.gain);
      rattleLfo.start(time);
      rattleLfo.stop(time + envDur + 0.05);
    }

    wireNoise.connect(wireHP);
    wireHP.connect(wireBP);
    wireBP.connect(wireAmpGain);
    wireAmpGain.connect(masterOut);
    wireNoise.start(time);
    wireNoise.stop(time + envDur + 0.05);
  }
  voiceEntry.endTime = time + envDur + 0.1;
}

// ════════════════════════════════════════════════════════════════
// Freeze — micro-granular resonator: freezes exciter into a sustaining
// texture via overlapping Hann-windowed grains with spectral processing
// ════════════════════════════════════════════════════════════════
function triggerFreeze(time) {
  const v = computeVariation(state.drumFreezeVariation ?? 0);
  const d = computeDistance(state.drumFreezeDistance ?? 0.5);

  const { outGain: voiceOut, entry: voiceEntry } = acquireVoice('freeze');

  const excType     = state.drumFreezeExciter ?? 'impulse';
  const excFreq     = (state.drumFreezeExcFreq ?? 440) * v.vPitch;
  const excBright   = (state.drumFreezeExcBright ?? 0.5) * v.vBright * d.dBright;
  // Center: extended freeze amount
  const freezeAmt   = Math.min(1, clEd(state.drumFreezeAmount ?? 0.5, d.t, CL_ED.freeze.freezeAmt));
  const grainSize   = Math.max(0.005, (state.drumFreezeGrainSize ?? 40) / 1000);
  // Center: more grain overlap (higher density)
  const density     = Math.max(1, Math.round(clEd(state.drumFreezeDensity ?? 8, d.t, CL_ED.freeze.density)));
  const spread      = state.drumFreezeSpread ?? 0.3;
  const jitter      = state.drumFreezeJitter ?? 0.1;
  const tilt        = state.drumFreezeTilt ?? 0;
  const formant     = state.drumFreezeFormant ?? 0;
  const pitchShift  = state.drumFreezePitchShift ?? 0;
  // Center: shimmer increases for sustained texture
  const shimmer     = clEd(state.drumFreezeShimmer ?? 0, d.t, CL_ED.freeze.shimmer);
  const shimmerRate = state.drumFreezeShimmerRate ?? 3;
  const filterFreq  = Math.max(20, Math.min(20000, (state.drumFreezeFilterFreq ?? 8000) * d.dBright));
  const filterQ     = state.drumFreezeFilterQ ?? 0.7;
  const filterType  = state.drumFreezeFilterType ?? 'lowpass';
  const attack      = (state.drumFreezeAttack ?? 10) / 1000 * v.vAttack * d.dAttack;
  const decay       = Math.min(MAX_DECAY_SEC, (state.drumFreezeDecay ?? 1200) / 1000 * v.vDecay * d.dDecay);
  const level       = (state.drumFreezeLevel ?? 0.5) * 0.8 * v.vLevel * d.dLevel;

  const envDur = attack + decay;
  const masterOut = audioCtx.createGain();
  masterOut.gain.value = 1.0;
  masterOut.connect(voiceOut);

  // ── Build exciter source buffer (longer buffer = more timbral variety) ──
  const excDur = Math.max(grainSize * 8, 0.15); // much longer buffer to avoid repetitive looping
  const excSamples = Math.ceil(audioCtx.sampleRate * excDur);
  const excBuf = audioCtx.createBuffer(1, excSamples, audioCtx.sampleRate);
  const excData = excBuf.getChannelData(0);

  if (excType === 'noise') {
    // Filtered noise — use brightness to control spectral shape
    for (let i = 0; i < excSamples; i++) {
      excData[i] = (Math.random() * 2 - 1);
    }
    // Apply simple smoothing for softer noise at low brightness
    if (excBright < 0.7) {
      const smooth = 1 - excBright;
      let prev = 0;
      for (let i = 0; i < excSamples; i++) {
        excData[i] = excData[i] * (1 - smooth * 0.6) + prev * smooth * 0.6;
        prev = excData[i];
      }
    }
  } else if (excType === 'tone') {
    // Tone with evolving harmonics — add slight detuning and noise floor
    // to prevent pure-siren artifacts when granulated
    for (let i = 0; i < excSamples; i++) {
      const t = i / audioCtx.sampleRate;
      // Slight drift in phase over time for organic quality
      const drift = 1 + 0.002 * Math.sin(2 * Math.PI * 0.7 * t);
      excData[i] = Math.sin(2 * Math.PI * excFreq * drift * t) * 0.7;
      // Harmonics with detuning
      if (excBright > 0.2) excData[i] += 0.3 * excBright * Math.sin(2 * Math.PI * excFreq * 2.003 * t);
      if (excBright > 0.5) excData[i] += 0.15 * excBright * Math.sin(2 * Math.PI * excFreq * 3.01 * t);
      // Subtle noise floor for texture (prevents pure siren)
      excData[i] += (Math.random() * 2 - 1) * 0.05 * (1 - excBright * 0.5);
    }
  } else if (excType === 'pluck') {
    // Karplus-Strong-ish exciter — longer decay for richer source
    const period = Math.round(audioCtx.sampleRate / excFreq);
    for (let i = 0; i < period && i < excSamples; i++) {
      excData[i] = (Math.random() * 2 - 1) * (1 - excBright * 0.3);
    }
    const dampFactor = 0.48 + excBright * 0.15; // slightly less than 0.5 for natural decay
    for (let i = period; i < excSamples; i++) {
      excData[i] = (excData[i - period] + excData[i - period + 1]) * dampFactor;
    }
  } else {
    // impulse: short transient burst + longer resonant tail
    const burstLen = Math.min(excSamples, Math.ceil(audioCtx.sampleRate * 0.004));
    for (let i = 0; i < burstLen; i++) {
      const env = 1 - i / burstLen;
      excData[i] = (Math.random() * 2 - 1) * env * 0.8;
      excData[i] += 0.3 * env * Math.sin(2 * Math.PI * excFreq * i / audioCtx.sampleRate);
    }
    // Add a fading resonant tail so there's material to freeze
    for (let i = burstLen; i < excSamples; i++) {
      const tailEnv = Math.exp(-(i - burstLen) / (audioCtx.sampleRate * 0.05));
      excData[i] = tailEnv * 0.15 * Math.sin(2 * Math.PI * excFreq * i / audioCtx.sampleRate);
      excData[i] += (Math.random() * 2 - 1) * tailEnv * 0.03;
    }
  }

  // ── Spectral tilt (apply to exciter buffer) ──
  if (Math.abs(tilt) > 0.01) {
    // Simple one-pole filter in the time domain
    let prev = 0;
    const coeff = tilt > 0 ? 0.9 * tilt : 0;
    const hpCoeff = tilt < 0 ? 0.9 * Math.abs(tilt) : 0;
    for (let i = 0; i < excSamples; i++) {
      if (tilt > 0) {
        // Darken (low-pass emphasis)
        excData[i] = excData[i] * (1 - coeff) + prev * coeff;
      } else {
        // Brighten (high-pass emphasis)
        const raw = excData[i];
        excData[i] = raw - prev * (1 - hpCoeff);
        prev = raw; continue;
      }
      prev = excData[i];
    }
  }

  // ── Pitch shift factor ──
  const psFactor = pitchShift !== 0 ? Math.pow(2, pitchShift / 12) : 1.0;

  // ── Granular overlap-add engine ──
  const grainSamples = Math.ceil(audioCtx.sampleRate * grainSize);
  const MAX_GRAINS = 600; // prevent audio-graph overload
  const MIN_GRAIN_INTERVAL = 0.002; // 2ms floor
  let grainInterval = Math.max(MIN_GRAIN_INTERVAL, grainSize / Math.max(1, density * 0.5));
  let totalGrains = Math.ceil(envDur / grainInterval);
  // If grain count exceeds cap, widen the interval to fit
  if (totalGrains > MAX_GRAINS) {
    grainInterval = envDur / MAX_GRAINS;
    totalGrains = MAX_GRAINS;
  }

  // Main output filter
  const outFilter = audioCtx.createBiquadFilter();
  outFilter.type = filterType;
  outFilter.frequency.value = filterFreq;
  outFilter.Q.value = filterQ;

  // Gentle high-shelf rolloff to tame harsh granular artifacts
  const softener = audioCtx.createBiquadFilter();
  softener.type = 'highshelf';
  softener.frequency.value = 3000;
  softener.gain.value = -4;    // -4 dB above 3kHz
  outFilter.connect(softener);
  softener.connect(masterOut);

  // Shimmer LFO
  let shimmerLfo = null, shimmerLfoGain = null;
  if (shimmer > 0.01) {
    shimmerLfo = audioCtx.createOscillator();
    shimmerLfo.type = 'sine';
    shimmerLfo.frequency.value = shimmerRate;
    shimmerLfoGain = audioCtx.createGain();
    shimmerLfoGain.gain.value = shimmer * 0.3;
    shimmerLfo.connect(shimmerLfoGain);
    shimmerLfo.start(time);
    shimmerLfo.stop(time + envDur + 0.1);
  }

  // Formant resonances
  let formantNode = null;
  if (formant > 0.05) {
    formantNode = audioCtx.createGain();
    formantNode.gain.value = formant * 0.6;
    const formantFreqs = [500, 1500, 2500, 3500];
    formantFreqs.forEach(ff => {
      const fb = audioCtx.createBiquadFilter();
      fb.type = 'bandpass';
      fb.frequency.value = ff;
      fb.Q.value = 5 + formant * 10;
      const fg = audioCtx.createGain();
      fg.gain.value = 0.25;
      formantNode.connect(fb);
      fb.connect(fg);
      fg.connect(outFilter);
    });
  }

  for (let g = 0; g < totalGrains; g++) {
    const grainTime = time + g * grainInterval;
    if (grainTime > time + envDur) break;

    // Jitter the grain start position within the exciter buffer
    const jitterOffset = jitter * (Math.random() * 2 - 1) * grainSize;
    const spreadPan = spread * (Math.random() * 2 - 1);

    // Create Hann-windowed grain buffer
    const gBuf = audioCtx.createBuffer(1, grainSamples, audioCtx.sampleRate);
    const gData = gBuf.getChannelData(0);
    // Freeze amount controls how much the read position stays locked vs advances
    // Add inherent micro-jitter even at high freeze to prevent static siren tone
    const progressOffset = (1 - freezeAmt) * (g * grainInterval / envDur) * excSamples;
    const microJitter = (Math.random() * 2 - 1) * excSamples * 0.08 * (0.3 + freezeAmt * 0.7);
    const readOffset = Math.floor(progressOffset + jitterOffset * audioCtx.sampleRate + microJitter);
    for (let i = 0; i < grainSamples; i++) {
      const hannW = 0.5 * (1 - Math.cos(2 * Math.PI * i / grainSamples));
      const srcIdx = ((readOffset + i) % excSamples + excSamples) % excSamples;
      gData[i] = excData[srcIdx] * hannW;
    }

    const grainSrc = audioCtx.createBufferSource();
    grainSrc.buffer = gBuf;
    grainSrc.playbackRate.value = psFactor;

    // Amplitude envelope per grain
    const gGain = audioCtx.createGain();
    const envPos = (grainTime - time) / envDur;
    let envLevel;
    if (envPos < (attack / envDur)) {
      envLevel = attack > 0 ? (envPos / (attack / envDur)) * level : level;
    } else {
      envLevel = level * Math.exp(-3 * (envPos - attack / envDur));
    }
    gGain.gain.value = envLevel / Math.max(1, density * 0.5) * 0.7;

    // Shimmer modulation
    if (shimmerLfoGain) {
      shimmerLfoGain.connect(gGain.gain);
    }

    // Connect grain → gain → [formant|filter] → output
    grainSrc.connect(gGain);

    if (formantNode && formant > 0.05) {
      gGain.connect(formantNode);
      // Also direct path
      const directGain = audioCtx.createGain();
      directGain.gain.value = 1 - formant * 0.4;
      gGain.connect(directGain);
      directGain.connect(outFilter);
    } else {
      gGain.connect(outFilter);
    }

    grainSrc.start(grainTime);
    grainSrc.stop(grainTime + grainSize / psFactor + 0.002);
  }
  voiceEntry.endTime = time + envDur + 0.1;
}

function triggerVoice(voiceKey) {
  const t = audioCtx.currentTime + 0.005;
  switch (voiceKey) {
    case 'sub':    triggerSub(t); break;
    case 'kick':   triggerKick(t); break;
    case 'click':  triggerClick(t); break;
    case 'beepHi': triggerBeepHi(t); break;
    case 'beepLo': triggerBeepLo(t); break;
    case 'noise':  triggerNoise(t); break;
    case 'membrane': triggerMembrane(t); break;
    case 'freeze': triggerFreeze(t); break;
  }
  startSpectrogramCapture(voiceKey);
}

document.querySelectorAll('.trigger-btn').forEach((btn) => {
  btn.addEventListener('click', async () => {
    await ensureAudio();
    const voiceKey = btn.dataset.voice;
    triggerVoice(voiceKey);
  });
});

const KEY_TO_VOICE = {
  a: 'sub',
  s: 'kick',
  d: 'click',
  f: 'beepHi',
  g: 'beepLo',
  h: 'noise',
  j: 'membrane',
  k: 'freeze',
};

window.addEventListener('keydown', async (event) => {
  const tag = event.target?.tagName;
  if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;
  if (event.repeat) return;
  const voiceKey = KEY_TO_VOICE[event.key?.toLowerCase()];
  if (!voiceKey) return;
  event.preventDefault();
  await ensureAudio();
  triggerVoice(voiceKey);
});

// ══════════════════════════════════════════════════════════════════
// LIVE SPECTROGRAM / WAVEFORM / LEVEL METER
// ══════════════════════════════════════════════════════════════════

// Heatmap color: magnitude 0-255 → RGB
function spectColor(mag) {
  // Black → deep blue → cyan → yellow → white
  if (mag < 32)  return `rgb(0,0,${mag * 2})`;
  if (mag < 96)  return `rgb(0,${(mag - 32) * 4},${64 + (mag - 32) * 3})`;
  if (mag < 192) return `rgb(${(mag - 96) * 2.5},${255},${255 - (mag - 96) * 2.5})`;
  return `rgb(255,${255 - (mag - 192) * 4},${(mag - 192) * 4})`;
}

function startSpectrogramCapture(voiceKey) {
  if (!analyserNode) return;

  // Re-entry guard: clean up any existing capture for this voice
  const prev = spectrogramState[voiceKey];
  if (prev) {
    prev.capturing = false;
    if (prev.captureId) clearInterval(prev.captureId);
    if (prev.animId) cancelAnimationFrame(prev.animId);
  }

  // Compute dynamic duration & column count for this voice
  const captureDurationMs = getVoiceCaptureDuration(voiceKey);
  const maxCols = Math.max(SPECT_COLS_DEFAULT, Math.ceil(captureDurationMs / SPECT_CAPTURE_MS));

  // Reset spectrogram data
  const bins = analyserNode.frequencyBinCount;
  const ss = {
    columns: [],         // Array of Uint8Arrays (FFT snapshots)
    waveform: null,      // Latest waveform
    peak: 0,             // Peak level 0-1
    startTime: performance.now(),
    capturing: true,
    voiceKey: voiceKey,
    animId: null,
    captureId: null,
    fadeAlpha: 1.0,
    captureDurationMs: captureDurationMs,
    maxCols: maxCols,
  };
  spectrogramState[voiceKey] = ss;

  // Update label
  const lbl = document.getElementById(`viz-label-${voiceKey}`);
  if (lbl) lbl.textContent = 'live';

  // Capture FFT at regular intervals
  ss.captureId = setInterval(() => {
    if (!ss.capturing) { clearInterval(ss.captureId); return; }
    const elapsed = performance.now() - ss.startTime;
    if (elapsed > ss.captureDurationMs) {
      ss.capturing = false;
      clearInterval(ss.captureId);
      // Begin fade back to envelopes
      fadeBackToEnvelopes(voiceKey);
      return;
    }
    const col = new Uint8Array(bins);
    analyserNode.getByteFrequencyData(col);
    ss.columns.push(col);
    // Keep only last N columns
    if (ss.columns.length > ss.maxCols) ss.columns.shift();
    // Waveform
    const wf = new Uint8Array(analyserNode.fftSize);
    analyserNode.getByteTimeDomainData(wf);
    ss.waveform = wf;
    // Peak
    let mx = 0;
    for (let i = 0; i < wf.length; i++) {
      const v = Math.abs(wf[i] - 128) / 128;
      if (v > mx) mx = v;
    }
    ss.peak = Math.max(ss.peak * 0.92, mx); // hold with slight decay
  }, SPECT_CAPTURE_MS);

  // Start render loop
  function renderLoop() {
    drawCombinedViz(voiceKey);
    if (ss.capturing || ss.fadeAlpha > 0.01) {
      ss.animId = requestAnimationFrame(renderLoop);
    } else {
      // Done fading — restore pure envelope view
      const lbl2 = document.getElementById(`viz-label-${voiceKey}`);
      if (lbl2) lbl2.textContent = 'envelopes';
      drawEnvelopes(voiceKey);
    }
  }
  if (ss.animId) cancelAnimationFrame(ss.animId);
  renderLoop();
}

function fadeBackToEnvelopes(voiceKey) {
  const ss = spectrogramState[voiceKey];
  if (!ss) return;
  const lbl = document.getElementById(`viz-label-${voiceKey}`);
  if (lbl) lbl.textContent = 'fading...';

  function fadeStep() {
    ss.fadeAlpha -= 0.02;
    if (ss.fadeAlpha <= 0) {
      ss.fadeAlpha = 0;
    }
  }
  const fadeId = setInterval(() => {
    fadeStep();
    if (ss.fadeAlpha <= 0) clearInterval(fadeId);
  }, 30);
}

function drawCombinedViz(voiceKey) {
  const canvas = document.getElementById(`viz-${voiceKey}`);
  if (!canvas) return;
  const ss = spectrogramState[voiceKey];
  if (!ss) return;

  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  if (rect.width === 0) return;

  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  const w = rect.width;
  const h = rect.height;
  const pad = { top: 14, right: 8, bottom: 14, left: 8 };

  // Layout: top half = envelope curves, bottom half = spectrogram+waveform+meter
  const envH = Math.floor((h - pad.top - pad.bottom) * 0.42);
  const gap = 6;
  const liveY = pad.top + envH + gap;
  const liveH = h - liveY - pad.bottom;
  const plotW = w - pad.left - pad.right;

  ctx.clearRect(0, 0, w, h);

  // ═══ TOP: Envelope Curves (always visible) ═══
  drawEnvelopeRegion(ctx, voiceKey, pad.left, pad.top, plotW, envH);

  // ═══ BOTTOM: Live analysis (fades with alpha) ═══
  const alpha = ss.fadeAlpha;
  if (alpha < 0.01 && !ss.capturing) return;

  ctx.globalAlpha = alpha;

  // ── Separator line ──
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 0.5;
  ctx.beginPath();
  ctx.moveTo(pad.left, liveY - 2);
  ctx.lineTo(pad.left + plotW, liveY - 2);
  ctx.stroke();

  // Split live area: spectrogram (70%), waveform+meter (30%)
  const spectW = Math.floor(plotW * 0.68);
  const waveX = pad.left + spectW + 6;
  const waveW = plotW - spectW - 6;

  // ── Spectrogram ──
  if (ss.columns.length > 0) {
    const bins = ss.columns[0].length;
    // Per-voice frequency zoom — only show up to the voice's ceiling
    const ceiling = VOICE_FREQ_CEILING[voiceKey] || 10000;
    const nyquist = audioCtx ? audioCtx.sampleRate / 2 : 22050;
    const maxBin = Math.min(bins, Math.round(ceiling / nyquist * bins));
    const colW = spectW / (ss.maxCols || SPECT_COLS_DEFAULT);
    const binH = liveH / maxBin;

    // Draw columns
    for (let c = 0; c < ss.columns.length; c++) {
      const col = ss.columns[c];
      const x = pad.left + c * colW;
      for (let b = 0; b < maxBin; b++) {
        const mag = col[b];
        if (mag < 8) continue; // skip near-silence for perf
        ctx.fillStyle = spectColor(mag);
        // Flip Y so low freq at bottom
        const y = liveY + liveH - (b + 1) * binH;
        ctx.fillRect(x, y, colW + 0.5, binH + 0.5);
      }
    }

    // Frequency axis labels (right side of spectrogram)
    if (audioCtx) {
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.font = '7px sans-serif';
      ctx.textAlign = 'right';
      const nyquist = audioCtx.sampleRate / 2;
      // Pick frequency axis labels appropriate for the voice's ceiling
      const ceil = VOICE_FREQ_CEILING[voiceKey] || 10000;
      const freqMarks = ceil <= 500
        ? [50, 100, 200, 300, 400]
        : ceil <= 1000
          ? [100, 250, 500, 750, 1000]
          : ceil <= 5000
            ? [200, 500, 1000, 2000, 4000]
            : [500, 1000, 2000, 5000, 10000];
      for (const f of freqMarks) {
        const bin = Math.round(f / nyquist * bins);
        if (bin >= maxBin) continue;
        const y = liveY + liveH - bin * binH;
        if (y < liveY + 6 || y > liveY + liveH - 4) continue;
        const label = f >= 1000 ? (f / 1000) + 'k' : f + '';
        ctx.fillText(label, pad.left + spectW - 2, y + 3);
      }
    }

    // Spectrogram label
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.font = '7px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('SPECTRUM', pad.left + 2, liveY + 8);
  } else {
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('awaiting signal...', pad.left + spectW / 2, liveY + liveH / 2);
  }

  // ── Waveform ──
  if (ss.waveform) {
    const wfH = Math.floor(liveH * 0.55);
    const wfY = liveY;

    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.fillRect(waveX, wfY, waveW, wfH);

    // Center line
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 0.5;
    ctx.beginPath();
    ctx.moveTo(waveX, wfY + wfH / 2);
    ctx.lineTo(waveX + waveW, wfY + wfH / 2);
    ctx.stroke();

    // Waveform line
    ctx.beginPath();
    ctx.strokeStyle = VOICES[voiceKey]?.color || '#a78bfa';
    ctx.lineWidth = 1.2;
    const wfLen = ss.waveform.length;
    const step = Math.max(1, Math.floor(wfLen / waveW));
    for (let i = 0; i < waveW; i++) {
      const idx = Math.floor(i * wfLen / waveW);
      const v = (ss.waveform[idx] - 128) / 128;  // -1 to 1
      const y = wfY + wfH / 2 - v * (wfH / 2 - 2);
      if (i === 0) ctx.moveTo(waveX + i, y);
      else ctx.lineTo(waveX + i, y);
    }
    ctx.stroke();

    // Label
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.font = '7px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('WAVE', waveX + 2, wfY + 8);

    // ── Level meter ──
    const meterY = wfY + wfH + 4;
    const meterH = liveH - wfH - 8;
    if (meterH > 8) {
      // Background
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(waveX, meterY, waveW, meterH);

      // Level bar
      const peak = Math.min(1, ss.peak);
      const barW = peak * (waveW - 4);
      const grad = ctx.createLinearGradient(waveX + 2, 0, waveX + waveW - 2, 0);
      grad.addColorStop(0, '#22c55e');
      grad.addColorStop(0.6, '#eab308');
      grad.addColorStop(0.85, '#ef4444');
      ctx.fillStyle = grad;
      ctx.fillRect(waveX + 2, meterY + 2, barW, meterH - 4);

      // dB text
      const db = peak > 0.001 ? (20 * Math.log10(peak)).toFixed(0) : '-∞';
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = '8px sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText(db + 'dB', waveX + waveW - 3, meterY + meterH / 2 + 3);

      // Label
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.font = '7px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('LEVEL', waveX + 2, meterY + 8);
    }
  }

  ctx.globalAlpha = 1;
}

// Draw envelope curves into a specific region (used by both modes)
function drawEnvelopeRegion(ctx, voiceKey, x, y, w, h) {
  const pad = { top: 12, right: 4, bottom: 10, left: 4 };
  const plotW = w - pad.left - pad.right;
  const plotH = h - pad.top - pad.bottom;
  if (plotW < 10 || plotH < 10) return;

  const curves = getEnvelopeCurves(voiceKey);
  if (curves.length === 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.font = '9px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('No active envelopes', x + w / 2, y + h / 2);
    return;
  }

  const maxTime = Math.max(...curves.map(c => c.maxTime));
  const ox = x + pad.left;
  const oy = y + pad.top;

  // Grid
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 3; i++) {
    const gy = oy + (plotH * i / 3);
    ctx.beginPath();
    ctx.moveTo(ox, gy);
    ctx.lineTo(ox + plotW, gy);
    ctx.stroke();
  }

  // Time axis
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.font = '7px sans-serif';
  ctx.textAlign = 'center';
  const tSteps = maxTime > 0.5 ? 4 : 3;
  for (let i = 0; i <= tSteps; i++) {
    const t = maxTime * i / tSteps;
    const tx = ox + (plotW * i / tSteps);
    const label = t >= 1 ? t.toFixed(1) + 's' : Math.round(t * 1000) + 'ms';
    ctx.fillText(label, tx, y + h - 1);
  }

  // Curves
  curves.forEach(curve => {
    const pts = curve.points;

    // Fill
    ctx.beginPath();
    ctx.moveTo(ox, oy + plotH);
    pts.forEach(pt => {
      ctx.lineTo(ox + (pt.t / maxTime) * plotW, oy + plotH - pt.v * plotH);
    });
    ctx.lineTo(ox + (pts[pts.length - 1].t / maxTime) * plotW, oy + plotH);
    ctx.closePath();
    ctx.fillStyle = curve.color;
    ctx.globalAlpha = 0.05;
    ctx.fill();

    // Stroke
    ctx.beginPath();
    ctx.strokeStyle = curve.color;
    ctx.lineWidth = 1.5;
    ctx.globalAlpha = 0.8;
    let started = false;
    pts.forEach(pt => {
      const px = ox + (pt.t / maxTime) * plotW;
      const py = oy + plotH - pt.v * plotH;
      if (!started) { ctx.moveTo(px, py); started = true; }
      else ctx.lineTo(px, py);
    });
    ctx.stroke();
    ctx.globalAlpha = 1;
  });

  // Legend (compact)
  ctx.font = '7px sans-serif';
  ctx.textAlign = 'right';
  ctx.globalAlpha = 0.8;
  let lx = x + w - pad.right;
  for (let i = curves.length - 1; i >= 0; i--) {
    const c = curves[i];
    const tw = ctx.measureText(c.name).width;
    ctx.fillStyle = c.color;
    ctx.fillText(c.name, lx, y + pad.top - 2);
    lx -= tw + 4;
    ctx.beginPath();
    ctx.arc(lx, y + pad.top - 5, 2.5, 0, Math.PI * 2);
    ctx.fill();
    lx -= 8;
  }
  ctx.globalAlpha = 1;
}

// ══════════════════════════════════════════════════════════════════
// SUPER SEQUENCER — 4 independent sequencers with tabs
// 3-lane each: Euclidean Trigger + Pitch + Expression
// Multi-source: randomly picks from selected voices per hit
// Per-step probability as draggable bars (like velocity)
// Mute/Solo, per-seq clock division + swing
// ══════════════════════════════════════════════════════════════════

const SEQ_COLORS = ['#00d4ff', '#ff6b81', '#22c55e', '#ffa502'];
const SEQ_NAMES = ['Seq 1', 'Seq 2', 'Seq 3', 'Seq 4'];
const SEQ_DEFAULT_SOURCES = [
  { kick: true },
  { beepHi: true },
  { click: true },
  { noise: true },
];
const SEQ_DEFAULT_EUCLID = [
  { steps: 8, hits: 5 },
  { steps: 16, hits: 3 },
  { steps: 12, hits: 5 },
  { steps: 8, hits: 3 },
];

// ── Tonal constants ──
const SEQ_NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const SEQ_SCALES = {
  'Chromatic':  [0,1,2,3,4,5,6,7,8,9,10,11],
  'Major':      [0,2,4,5,7,9,11],
  'Minor':      [0,2,3,5,7,8,10],
  'Pentatonic': [0,2,4,7,9],
  'Min Penta':  [0,3,5,7,10],
  'Dorian':     [0,2,3,5,7,9,10],
  'Phrygian':   [0,1,3,5,7,8,10],
  'Lydian':     [0,2,4,6,7,9,11],
  'Mixolydian': [0,2,4,5,7,9,10],
  'Harm Minor': [0,2,3,5,7,8,11],
  'Mel Minor':  [0,2,3,5,7,9,11],
  'Blues':       [0,3,5,6,7,10],
  'Whole Tone': [0,2,4,6,8,10],
};
const SEQ_TUNING_A4 = 432;

function seqNoteFreq(midi) {
  return SEQ_TUNING_A4 * Math.pow(2, (midi - 69) / 12);
}

function seqMidiToName(midi) {
  const note = SEQ_NOTE_NAMES[((midi % 12) + 12) % 12];
  const oct = Math.floor(midi / 12) - 1;
  return note + oct;
}

// Convert scale degree (can be negative) to MIDI note offset from root
function seqScaleDegreeToSemitone(degree, scale) {
  const len = scale.length;
  if (len === 0) return degree;
  const octaves = Math.floor(degree / len);
  const idx = ((degree % len) + len) % len;
  return octaves * 12 + scale[idx];
}

// Find nearest scale degree for a semitone offset
function seqSemitoneToScaleDegree(semi, scale) {
  const len = scale.length;
  const octaves = Math.floor(semi / 12);
  const rem = ((semi % 12) + 12) % 12;
  let bestIdx = 0, bestDist = 99;
  for (let i = 0; i < len; i++) {
    const d = Math.abs(scale[i] - rem);
    if (d < bestDist) { bestDist = d; bestIdx = i; }
  }
  return octaves * len + bestIdx;
}

let seqGlobalBpm = 120;
let seqPlaying = false;
let seqTimerID = null;
let seqActiveTab = 0;
let seqViewMode = 'detail'; // 'detail' | 'overview'

function createSequencer(id) {
  const euc = SEQ_DEFAULT_EUCLID[id] || { steps: 8, hits: 5 };
  return {
    id,
    rng: mulberry32(xmur3(String(Date.now() + id * 7919 + Math.random() * 1e6))()),
    color: SEQ_COLORS[id],
    name: SEQ_NAMES[id],
    muted: false,
    solo: false,
    clockDiv: id === 0 ? '1/8' : id === 1 ? '1/16' : id === 2 ? '1/8T' : '1/4',
    swing: 0,
    sources: { sub: false, kick: false, click: false, beepHi: false, beepLo: false, noise: false, membrane: false, freeze: false, ...(SEQ_DEFAULT_SOURCES[id] || {}) },
    trigger: {
      enabled: true,
      steps: euc.steps, hits: euc.hits, rotation: 0,
      pattern: [], overrides: new Set(),
      probability: new Array(16).fill(1.0),
      ratchet: new Array(16).fill(1),
    },
    pitch: {
      enabled: false,
      steps: 5,
      offsets: [0, 4, 7, 12, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      expanded: false,
      mode: 'semitones', // 'semitones' or 'notes'
      root: 60, // MIDI note number (C4)
      scale: 'Major',
    },
    expression: {
      enabled: false,
      steps: 5,
      velocities: [1.0, 0.8, 0.9, 0.7, 0.85, 1.0, 0.8, 0.9, 0.7, 0.85, 1.0, 0.8, 0.9, 0.7, 0.85, 1.0],
      expanded: false,
    },
    morph: {
      enabled: false,
      steps: 4,
      values: [1.0, 0.75, 0.5, 0.25, 0.5, 0.75, 1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
      expanded: false,
    },
    distance: {
      enabled: false,
      steps: 4,
      values: new Array(16).fill(0.5),
      expanded: false,
    },
    // scheduler state
    stepIndex: 0, hitCount: 0, nextTime: 0, lastDisplayStep: -1,
    totalStepCount: 0, // never wraps, for bar tracking
    linked: false, // Link pitch/expr steps to trigger steps
    // Generative evolution state
    evolve: {
      enabled: false,
      everyBars: 4,
      intensity: 25, // 0-100
      lastEvolveBar: -1,
      // per-method toggles (auto-set by intensity, can be overridden)
      methods: {
        rotateDrift: true,
        velocityBreath: true,
        swingDrift: true,
        probDrift: false,
        morphDrift: false,
        ghostNotes: false,
        hitDrift: false,
        ratchetSpray: false,
        pitchWalk: false,
      },
      // Home pattern snapshot for gravity
      home: null,
    },
  };
}

const sequencers = [createSequencer(0), createSequencer(1), createSequencer(2), createSequencer(3)];
// Initialize patterns
sequencers.forEach(s => { s.trigger.pattern = seqEuclidean(s.trigger.steps, s.trigger.hits, 0); });

const SEQ_EUC_PRESETS = {
  'Tresillo 3/8': { steps: 8, hits: 3 },
  'Cinquillo 5/8': { steps: 8, hits: 5 },
  'Bossa 5/16': { steps: 16, hits: 5 },
  'Rumba 5/12': { steps: 12, hits: 5 },
  '4-Floor 4/16': { steps: 16, hits: 4 },
  'Sparse 3/16': { steps: 16, hits: 3 },
  'Dense 7/8': { steps: 8, hits: 7 },
  'Aksak 4/9': { steps: 9, hits: 4 },
};

const SEQ_PITCH_PRESETS = {
  'Static': [0],
  '+Oct': [0, 12],
  '+5th': [0, 7],
  'Triad': [0, 4, 7],
  'Minor': [0, 3, 7],
  'Penta': [0, 2, 4, 7, 9],
  'Rand': null,
};

// Pitch presets for Notes mode (scale degrees)
const SEQ_PITCH_PRESETS_NOTES = {
  'Root': [0],
  '1-3-5': [0, 2, 4],
  '1-5': [0, 4],
  'Up 5': [0, 1, 2, 3, 4],
  'Down 5': [4, 3, 2, 1, 0],
  'Arp Up': [0, 2, 4, 6],
  'Rand': null,
};

function seq() { return sequencers[seqActiveTab]; }

// ── Euclidean algorithm (Bjorklund) ──
function seqEuclidean(steps, hits, rotation) {
  rotation = rotation || 0;
  if (hits >= steps) return new Array(steps).fill(true);
  if (hits <= 0) return new Array(steps).fill(false);
  let pattern = [], remainder = [];
  for (let i = 0; i < hits; i++) pattern.push([1]);
  for (let i = 0; i < steps - hits; i++) remainder.push([0]);
  while (remainder.length > 1) {
    const np = [], ml = Math.min(pattern.length, remainder.length);
    for (let i = 0; i < ml; i++) np.push([...pattern[i], ...remainder[i]]);
    remainder = pattern.length > remainder.length ? pattern.slice(ml) : remainder.slice(ml);
    pattern = np;
  }
  const flat = [];
  for (const p of [...pattern, ...remainder]) for (const v of p) flat.push(v === 1);
  return flat.map((_, i) => flat[(i + rotation) % flat.length]);
}

function seqGCD(a, b) { return b === 0 ? a : seqGCD(b, a % b); }
function seqLCM(a, b) { return (a * b) / seqGCD(a, b); }

function getClockSec(bpm, clockDiv) {
  const beat = 60.0 / bpm;
  switch (clockDiv) {
    case '1/4': return beat;
    case '1/8': return beat / 2;
    case '1/16': return beat / 4;
    case '1/8T': return beat / 3;
    default: return beat / 2;
  }
}

function getSeqActiveSources(s) {
  return Object.entries(s.sources).filter(([, on]) => on).map(([v]) => v);
}

function seqPickVoice(s) {
  const srcs = getSeqActiveSources(s);
  return srcs.length === 0 ? null : srcs[Math.floor(s.rng() * srcs.length)];
}

// ── Generative Evolution Engine ──

function seqSnapshotHome(s) {
  s.evolve.home = {
    rotation: s.trigger.rotation,
    probability: [...s.trigger.probability],
    ratchet: [...s.trigger.ratchet],
    velocities: [...s.expression.velocities],
    morphValues: [...s.morph.values],
    swing: s.swing,
    hits: s.trigger.hits,
    pitchOffsets: [...s.pitch.offsets],
    pattern: [...s.trigger.pattern],
    overrides: new Set(s.trigger.overrides),
  };
}

function seqEvolveIntensityToMethods(intensity) {
  return {
    rotateDrift: true,
    velocityBreath: true,
    swingDrift: true,
    probDrift: intensity > 30,
    morphDrift: intensity > 30,
    ghostNotes: intensity > 60,
    ratchetSpray: intensity > 60,
    hitDrift: intensity > 80,
    pitchWalk: intensity > 80,
  };
}

function seqEvolveStep(s) {
  if (!s.evolve.enabled) return;
  const bar = Math.floor(s.totalStepCount / s.trigger.steps);
  if (bar <= 0) return; // skip bar 0 (initial)
  if (bar === s.evolve.lastEvolveBar) return;
  if (bar % s.evolve.everyBars !== 0) { s.evolve.lastEvolveBar = bar; return; }
  s.evolve.lastEvolveBar = bar;

  // Snapshot home on first evolution
  if (!s.evolve.home) seqSnapshotHome(s);

  const m = s.evolve.methods;
  const intensity = s.evolve.intensity / 100;
  const home = s.evolve.home;
  let changed = false;

  // 1. Rotate Drift — shift rotation ±1, weighted toward no-change
  // At 25% intensity → 50% chance; at 100% → 80% chance
  if (m.rotateDrift) {
    const roll = s.rng();
    if (roll < 0.4 + 0.4 * intensity) {
      const dir = s.rng() < 0.5 ? 1 : -1;
      s.trigger.rotation = ((s.trigger.rotation + dir) % s.trigger.steps + s.trigger.steps) % s.trigger.steps;
      s.trigger.pattern = seqEuclidean(s.trigger.steps, s.trigger.hits, s.trigger.rotation);
      changed = true;
    }
  }

  // 2. Velocity Breath — gentle sine-like drift on expression velocities
  if (m.velocityBreath && s.expression.enabled) {
    for (let i = 0; i < s.expression.steps; i++) {
      const drift = (s.rng() * 2 - 1) * 0.08 * intensity;
      s.expression.velocities[i] = Math.max(0.2, Math.min(1.0, s.expression.velocities[i] + drift));
    }
    changed = true;
  }

  // 3. Swing Drift — random walk ±3%
  if (m.swingDrift) {
    const drift = (s.rng() * 2 - 1) * 0.03 * intensity;
    s.swing = Math.max(0, Math.min(0.75, s.swing + drift));
    changed = true;
  }

  // 4. Probability Drift — nudge active step probabilities ±5-10%
  if (m.probDrift) {
    for (let i = 0; i < s.trigger.steps; i++) {
      if (!s.trigger.pattern[i]) continue; // only active steps
      const drift = (s.rng() * 2 - 1) * 0.08 * intensity;
      s.trigger.probability[i] = Math.max(0.3, Math.min(1.0, s.trigger.probability[i] + drift));
    }
    changed = true;
  }

  // 5. Morph Lane Drift — random walk morph values ±5%
  if (m.morphDrift && s.morph.enabled) {
    for (let i = 0; i < s.morph.steps; i++) {
      const drift = (s.rng() * 2 - 1) * 0.05 * intensity;
      s.morph.values[i] = Math.max(0, Math.min(1.0, s.morph.values[i] + drift));
    }
    changed = true;
  }

  // 6. Ghost Note Injection — enable 1-2 inactive steps at low probability
  // Skip ghost notes for mono voices (Sub/Kick) — rapid choke chain sounds bad
  if (m.ghostNotes && s.rng() < 0.3 * intensity) {
    const srcs = getSeqActiveSources(s);
    const isMonoOnly = srcs.length > 0 && srcs.every(v => voicePools[v] && voicePools[v].max <= 1);
    if (!isMonoOnly) {
      const inactiveSteps = [];
      for (let i = 0; i < s.trigger.steps; i++) {
        if (!s.trigger.pattern[i] && !s.trigger.overrides.has(i)) inactiveSteps.push(i);
      }
      if (inactiveSteps.length > 0) {
        const count = Math.min(2, Math.ceil(inactiveSteps.length * 0.15));
        for (let c = 0; c < count && inactiveSteps.length > 0; c++) {
          const idx = inactiveSteps.splice(Math.floor(s.rng() * inactiveSteps.length), 1)[0];
          s.trigger.overrides.add(idx);
          s.trigger.pattern[idx] = true;
          s.trigger.probability[idx] = 0.15 + s.rng() * 0.2; // 15-35%
          // Ghost notes: lower velocity (20-40%) and shorter effective decay
          if (!s.trigger.ghostVelocity) s.trigger.ghostVelocity = {};
          s.trigger.ghostVelocity[idx] = 0.2 + s.rng() * 0.2; // 20-40% velocity
          if (!s.trigger.ghostDecay) s.trigger.ghostDecay = {};
          s.trigger.ghostDecay[idx] = 0.6 + s.rng() * 0.2;    // 60-80% decay
        }
        changed = true;
      }
    }
  }

  // 7. Ratchet Spray — toggle ratchet 1↔2 on active steps
  if (m.ratchetSpray && s.rng() < 0.2 * intensity) {
    const activeSteps = [];
    for (let i = 0; i < s.trigger.steps; i++) if (s.trigger.pattern[i]) activeSteps.push(i);
    if (activeSteps.length > 0) {
      const idx = activeSteps[Math.floor(s.rng() * activeSteps.length)];
      s.trigger.ratchet[idx] = s.trigger.ratchet[idx] === 1 ? 2 : 1;
      changed = true;
    }
  }

  // 8. Hit Count Drift — change Euclidean hits by ±1 (very rare)
  if (m.hitDrift && s.rng() < 0.15 * intensity) {
    const dir = s.rng() < 0.5 ? 1 : -1;
    const newHits = Math.max(1, Math.min(s.trigger.steps - 1, s.trigger.hits + dir));
    if (newHits !== s.trigger.hits) {
      s.trigger.hits = newHits;
      s.trigger.overrides.clear();
      s.trigger.pattern = seqEuclidean(s.trigger.steps, s.trigger.hits, s.trigger.rotation);
      changed = true;
    }
  }

  // 9. Pitch Walk — drift pitch offsets ±1 scale degree
  if (m.pitchWalk && s.pitch.enabled && s.rng() < 0.25 * intensity) {
    const idx = Math.floor(s.rng() * s.pitch.steps);
    const drift = s.rng() < 0.5 ? -1 : 1;
    const orig = home ? home.pitchOffsets[idx] : 0;
    const newVal = s.pitch.offsets[idx] + drift;
    // Clamp: never drift more than ±3 from home (regardless of pitch mode)
    if (Math.abs(newVal - orig) <= 3) {
      s.pitch.offsets[idx] = newVal;
      changed = true;
    }
  }

  // Home pattern gravity: 15% chance to revert one parameter toward home
  if (home && s.rng() < 0.15 * (1.2 - intensity)) {
    const gravityTargets = ['rotation', 'swing', 'probability', 'velocities'];
    const target = gravityTargets[Math.floor(s.rng() * gravityTargets.length)];
    switch (target) {
      case 'rotation':
        if (s.trigger.rotation !== home.rotation) {
          const diff = s.trigger.rotation - home.rotation;
          const step = diff > 0 ? -1 : 1;
          s.trigger.rotation = ((s.trigger.rotation + step) % s.trigger.steps + s.trigger.steps) % s.trigger.steps;
          s.trigger.pattern = seqEuclidean(s.trigger.steps, s.trigger.hits, s.trigger.rotation);
          s.trigger.overrides.clear(); // Clear overrides when regenerating pattern
          changed = true;
        }
        break;
      case 'swing':
        s.swing += (home.swing - s.swing) * 0.3;
        break;
      case 'probability':
        for (let i = 0; i < s.trigger.steps; i++) {
          s.trigger.probability[i] += (home.probability[i] - s.trigger.probability[i]) * 0.2;
        }
        break;
      case 'velocities':
        if (s.expression.enabled) {
          for (let i = 0; i < s.expression.steps; i++) {
            s.expression.velocities[i] += (home.velocities[i] - s.expression.velocities[i]) * 0.2;
          }
        }
        break;
    }
  }

  // Flash UI feedback (deferred to avoid conflict with scheduler loop)
  if (changed) {
    console.log('[Evolve] Seq ' + (s.id + 1) + ' mutated at bar ' + Math.floor(s.totalStepCount / s.trigger.steps) +
      ' | rot=' + s.trigger.rotation + ' hits=' + s.trigger.hits + ' swing=' + Math.round(s.swing * 100) + '%');
    if (s.id === seqActiveTab) {
      setTimeout(() => {
        const body = document.getElementById('seqBody');
        if (body) {
          body.classList.remove('seq-evolve-flash');
          void body.offsetWidth;
          body.classList.add('seq-evolve-flash');
        }
        seqRenderBody();
        seqRenderMiniOverview();
      }, 10);
    }
  }
}

function seqToggleEvolve() {
  const s = seq();
  s.evolve.enabled = !s.evolve.enabled;
  if (s.evolve.enabled && !s.evolve.home) seqSnapshotHome(s);
  if (!s.evolve.enabled) {
    // Optionally revert to home pattern
    s.evolve.lastEvolveBar = -1;
  }
  seqRenderBody();
}

function seqResetEvolve() {
  const s = seq();
  const home = s.evolve.home;
  if (!home) return;
  s.trigger.rotation = home.rotation;
  s.trigger.hits = home.hits;
  s.trigger.pattern = [...home.pattern];
  s.trigger.probability = [...home.probability];
  s.trigger.ratchet = [...home.ratchet];
  s.expression.velocities = [...home.velocities];
  s.morph.values = [...home.morphValues];
  s.swing = home.swing;
  s.pitch.offsets = [...home.pitchOffsets];
  s.trigger.overrides = new Set(home.overrides || []);
  s.evolve.lastEvolveBar = -1;
  seqRenderBody();
}

// ── Master scheduler: ticks all 4 sequencers ──
function seqMasterScheduler() {
  const now = audioCtx.currentTime;
  const hasSolo = sequencers.some(s => s.solo);
  for (const s of sequencers) {
    if (s.muted) continue;
    if (hasSolo && !s.solo) continue;
    if (getSeqActiveSources(s).length === 0) continue;

    const dur = getClockSec(seqGlobalBpm, s.clockDiv);
    let _pendingEvolve = false;
    while (s.nextTime < now + 0.1) {
      const swingOff = (s.stepIndex % 2 === 1) ? dur * s.swing * 0.5 : 0;
      seqScheduleStep(s, s.stepIndex, s.nextTime + swingOff, dur);
      s.nextTime += dur;
      s.stepIndex = (s.stepIndex + 1) % s.trigger.steps;
      s.totalStepCount++;
      // Mark evolution pending at bar boundaries — do NOT mutate inside the while loop
      // to prevent mid-bar pattern changes (race condition)
      if (s.stepIndex === 0 && s.evolve.enabled) {
        _pendingEvolve = true;
      }
    }
    // Apply evolution AFTER all steps in this tick are scheduled
    if (_pendingEvolve) seqEvolveStep(s);
  }
  seqTimerID = setTimeout(seqMasterScheduler, 25);
}

function seqScheduleStep(s, step, time, stepDur) {
  const isHit = !!s.trigger.enabled && (s.trigger.pattern[step] ?? false);

  // UI update
  const uiDelay = Math.max(0, (time - audioCtx.currentTime) * 1000);
  setTimeout(() => {
    seqUpdateMiniStep(s, step, isHit);
    if (s.id === seqActiveTab) seqUpdateStepDisplay(s, step, isHit);
    // Update overview grid if visible
    if (seqViewMode === 'overview') seqUpdateOvStep(s, step);
  }, uiDelay);

  if (!isHit) return;

  // Per-step probability
  const prob = s.trigger.probability[step] ?? 1.0;
  if (prob < 1.0 && s.rng() > prob) return;

  // Ratchet
  const ratchets = Math.max(1, s.trigger.ratchet[step] ?? 1);
  const rInt = stepDur / ratchets;

  // Pitch + Expression (polyrhythm via modulo)
  const pIdx = s.hitCount % s.pitch.steps;
  const eIdx = s.hitCount % s.expression.steps;
  const pitchOff = s.pitch.enabled ? (s.pitch.offsets[pIdx] ?? 0) : 0;
  const vel = s.expression.enabled ? (s.expression.velocities[eIdx] ?? 1.0) : 1.0;

  // Ghost note velocity + decay modifiers (evolution-injected ghost notes play softer & shorter)
  const ghostVelMul = (s.trigger.ghostVelocity && s.trigger.ghostVelocity[step]) ?? 1.0;
  const ghostDecMul = (s.trigger.ghostDecay && s.trigger.ghostDecay[step]) ?? 1.0;
  const effectiveVel = vel * ghostVelMul;

  // Preset Morph override: apply morph value to all active voices
  if (s.morph.enabled) {
    const mIdx = s.hitCount % s.morph.steps;
    const morphVal = s.morph.values[mIdx] ?? 1.0;
    // morphVal 1.0 = fully Preset A (slider 0), 0.0 = fully Preset B (slider 1)
    const sliderVal = 1 - morphVal;
    const voices = getSeqActiveSources(s);
    for (const v of voices) {
      const sl = document.getElementById('morph-' + v);
      if (sl) {
        sl.value = sliderVal;
        applyMorph(v);
      }
    }
  }

  // Distance override: apply distance value to all active voices + update UI sliders
  const _distKeys = { sub: 'drumSubDistance', kick: 'drumKickDistance', click: 'drumClickDistance', beepHi: 'drumBeepHiDistance', beepLo: 'drumBeepLoDistance', noise: 'drumNoiseDistance', membrane: 'drumMembraneDistance', freeze: 'drumFreezeDistance' };
  let _savedDist = null;
  if (s.distance.enabled) {
    const dIdx = s.hitCount % s.distance.steps;
    const distVal = s.distance.values[dIdx] ?? 0.5;
    const voices = getSeqActiveSources(s);
    _savedDist = {};
    for (const v of voices) {
      const dk = _distKeys[v];
      if (dk) {
        _savedDist[v] = state[dk];
        state[dk] = distVal;
        // Visually update drum engine slider
        const sl = document.querySelector('input[data-key="' + dk + '"]');
        if (sl) {
          sl.value = distVal;
          const valSpan = sl.parentElement && sl.parentElement.querySelector('.val');
          if (valSpan) valSpan.textContent = Math.round(distVal * 100) + '%';
        }
      }
    }
  }

  for (let r = 0; r < ratchets; r++) {
    const rt = time + r * rInt;
    const rv = effectiveVel * (r === 0 ? 1.0 : Math.pow(0.7, r));
    const voice = seqPickVoice(s);
    if (!voice) continue;
    seqTriggerVoice(voice, rt, pitchOff, rv, s.pitch.mode, s.pitch.root, s.pitch.scale, ghostDecMul);
  }

  // Restore distance values after triggering
  if (_savedDist) {
    for (const [v, val] of Object.entries(_savedDist)) {
      const dk = _distKeys[v];
      if (dk) state[dk] = val;
    }
  }

  s.hitCount++;
}

function seqTriggerVoice(voiceKey, time, pitchOff, velocity, pitchMode, pitchRoot, pitchScale, ghostDecMul) {
  ghostDecMul = ghostDecMul ?? 1.0;
  const cap = voiceKey.charAt(0).toUpperCase() + voiceKey.slice(1);
  const lk = 'drum' + cap + 'Level';
  const dk = 'drum' + cap + 'Decay';
  const fkMap = {
    sub: 'drumSubFreq', kick: 'drumKickFreq', click: 'drumClickPitch',
    beepHi: 'drumBeepHiFreq', beepLo: 'drumBeepLoFreq',
    membrane: 'drumMembraneSize', freeze: 'drumFreezeExcFreq'
  };
  const fk = fkMap[voiceKey];
  const oL = state[lk], oF = fk ? state[fk] : undefined;
  const oD = ghostDecMul < 0.99 ? state[dk] : undefined;
  state[lk] = (oL ?? 0.5) * velocity;
  // Ghost notes: shorten decay
  if (ghostDecMul < 0.99 && oD !== undefined) {
    state[dk] = oD * ghostDecMul;
  }

  if (pitchMode === 'notes' && fk && oF !== undefined) {
    // Absolute frequency from tonal system (432Hz default)
    const scale = SEQ_SCALES[pitchScale] || SEQ_SCALES['Major'];
    const midi = pitchRoot + seqScaleDegreeToSemitone(pitchOff, scale);
    state[fk] = seqNoteFreq(midi);
  } else if (pitchOff !== 0 && fk && oF !== undefined) {
    state[fk] = oF * Math.pow(2, pitchOff / 12);
  }

  switch (voiceKey) {
    case 'sub': triggerSub(time); break;
    case 'kick': triggerKick(time); break;
    case 'click': triggerClick(time); break;
    case 'beepHi': triggerBeepHi(time); break;
    case 'beepLo': triggerBeepLo(time); break;
    case 'noise': triggerNoise(time); break;
    case 'membrane': triggerMembrane(time); break;
    case 'freeze': triggerFreeze(time); break;
  }
  state[lk] = oL;
  if (fk && oF !== undefined) state[fk] = oF;
  if (ghostDecMul < 0.99 && oD !== undefined) state[dk] = oD;
}

// ── Transport ──
async function seqTogglePlay() {
  await ensureAudio();
  if (seqPlaying) {
    seqPlaying = false;
    clearTimeout(seqTimerID);
    document.getElementById('seqPlayBtn').textContent = '\u25b6';
    document.getElementById('seqPlayBtn').classList.remove('playing');
    document.querySelectorAll('.seq-step-cell.playing').forEach(el => el.classList.remove('playing'));
    sequencers.forEach(s => { s.lastDisplayStep = -1; });
  } else {
    // Check if ANY sequencer has active sources
    const anyActive = sequencers.some(s => !s.muted && getSeqActiveSources(s).length > 0);
    if (!anyActive) { alert('Select at least one source voice on an active sequencer'); return; }
    seqPlaying = true;
    const now = audioCtx.currentTime;
    sequencers.forEach(s => {
      s.stepIndex = 0; s.hitCount = 0; s.nextTime = now; s.totalStepCount = 0;
      s.evolve.lastEvolveBar = -1;
      if (s.evolve.enabled) seqSnapshotHome(s);
    });
    document.getElementById('seqPlayBtn').textContent = '\u25a0';
    document.getElementById('seqPlayBtn').classList.add('playing');
    seqMasterScheduler();
  }
}

// ── Space bar ──
window.addEventListener('keydown', (event) => {
  const tag = event.target?.tagName;
  if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;
  if (event.repeat) return;
  if (event.key === ' ') { event.preventDefault(); seqTogglePlay(); }
});

// ── View mode toggle ──
function seqSetView(mode) {
  seqViewMode = mode;
  document.querySelectorAll('.seq-view-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.view === mode);
  });
  document.getElementById('seqDetailWrap').style.display = mode === 'detail' ? '' : 'none';
  document.getElementById('seqOverviewWrap').style.display = mode === 'overview' ? '' : 'none';
  if (mode === 'detail') {
    seqRenderTabBar(); seqRenderBody(); seqRenderMiniOverview();
  } else {
    seqRenderOverview();
  }
}

// ── Tab switching ──
function seqSwitchTab(idx) {
  seqActiveTab = idx;
  if (seqViewMode === 'overview') {
    seqSetView('detail');
    return;
  }
  seqRenderTabBar();
  seqRenderBody();
  seqRenderMiniOverview();
}

// ── Mute/Solo ──
function seqToggleMute(idx, e) {
  e.stopPropagation();
  sequencers[idx].muted = !sequencers[idx].muted;
  seqRenderTabBar();
  seqRenderMiniOverview();
}
function seqToggleSolo(idx, e) {
  e.stopPropagation();
  sequencers[idx].solo = !sequencers[idx].solo;
  seqRenderTabBar();
  seqRenderMiniOverview();
}

// ── Link: sync pitch/expr steps to active trigger count ──
function seqSyncLinkedSteps(s) {
  if (!s.linked) return;
  const activeHits = s.trigger.pattern.filter(x => x).length;
  if (activeHits < 1) return; // need at least 1 step
  s.pitch.steps = activeHits;
  s.expression.steps = activeHits;
  // Update UI inputs if they exist (detail view)
  const pInp = document.getElementById('seqPitchSteps');
  const eInp = document.getElementById('seqExprSteps');
  if (pInp) pInp.value = activeHits;
  if (eInp) eInp.value = activeHits;
}

function seqToggleLink() {
  const s = seq();
  s.linked = !s.linked;
  if (s.linked) {
    seqSyncLinkedSteps(s);
    seqRenderPitchGrid();
    seqRenderExprGrid();
    seqUpdatePolyInfo();
  }
  const btn = document.getElementById('seqLinkBtn');
  if (btn) {
    btn.classList.toggle('on', s.linked);
    btn.textContent = 'Link';
  }
}

// ── Euclidean controls (operate on active tab seq) ──
function seqUpdateEuclidean() {
  const s = seq();
  const st = s.trigger;
  // Values are set by drag-num widgets before calling this, just clamp
  st.steps = Math.max(2, Math.min(16, st.steps));
  st.hits = Math.max(0, Math.min(st.steps, st.hits));
  const stepsEl = document.getElementById('seqTrigSteps');
  const hitsEl = document.getElementById('seqTrigHits');
  if (stepsEl) stepsEl.textContent = st.steps;
  if (hitsEl) hitsEl.textContent = st.hits;
  const newP = seqEuclidean(st.steps, st.hits, st.rotation);
  for (let i = 0; i < st.steps; i++) if (!st.overrides.has(i)) st.pattern[i] = newP[i];
  for (const idx of st.overrides) if (idx >= st.steps) st.overrides.delete(idx);
  while (st.pattern.length < st.steps) st.pattern.push(newP[st.pattern.length] || false);
  st.pattern = st.pattern.slice(0, st.steps);
  seqSyncLinkedSteps(s);
  seqRenderTriggerGrid();
  seqUpdatePatternDisplay();
  seqUpdatePolyInfo();
  seqRenderMiniOverview();
}

function seqRotate(dir) {
  const s = seq(), st = s.trigger;
  st.rotation = (st.rotation + dir + st.steps) % st.steps;
  document.getElementById('seqTrigRot').textContent = st.rotation;
  const newP = seqEuclidean(st.steps, st.hits, st.rotation);
  for (let i = 0; i < st.steps; i++) if (!st.overrides.has(i)) st.pattern[i] = newP[i];
  seqRenderTriggerGrid();
  seqUpdatePatternDisplay();
  seqRenderMiniOverview();
}

// ── Shared drag popup helper ──
let _dragPopup = null;
function seqShowDragPopup(clientX, clientY, text) {
  if (!_dragPopup) {
    _dragPopup = document.createElement('div');
    _dragPopup.className = 'seq-drag-popup';
    document.body.appendChild(_dragPopup);
  }
  _dragPopup.textContent = text;
  _dragPopup.style.left = clientX + 'px';
  _dragPopup.style.top = clientY + 'px';
  _dragPopup.style.display = 'block';
}
function seqHideDragPopup() {
  if (_dragPopup) _dragPopup.style.display = 'none';
}

// ── Drag-number: press-and-drag to change integer value with popup ──
// el = the .seq-drag-num element, opts = { min, max, get, set, label }
// get() returns current value, set(v) applies new value.
// Dragging up increases, down decreases. Sensitivity scales with range.
function seqDragNumBind(el, opts) {
  el.addEventListener('pointerdown', function(e) {
    if (e.button !== 0) return;
    e.preventDefault();
    e.stopPropagation();
    const pid = e.pointerId;
    el.setPointerCapture(pid);
    el.classList.add('dragging');
    let lastY = e.clientY;
    let accumY = 0;          // sub-step pixel accumulator
    let curVal = opts.get();
    let changed = false;
    // Scale sensitivity to range: small ranges (≤16) ~35px/step, large ranges (260+) ~2px/step
    const range = Math.max(1, opts.max() - opts.min);
    const pxPerStep = Math.max(2, Math.min(40, 500 / range));
    seqShowDragPopup(e.clientX, e.clientY, (opts.label || '') + curVal);

    const onMove = (ev) => {
      accumY += lastY - ev.clientY;   // up = positive
      lastY = ev.clientY;
      const steps = Math.trunc(accumY / pxPerStep);
      if (steps !== 0) {
        accumY -= steps * pxPerStep;   // keep remainder
        const newVal = Math.max(opts.min, Math.min(opts.max(), curVal + steps));
        if (newVal !== curVal) {
          curVal = newVal;
          el.textContent = curVal;
          opts.set(curVal);
          changed = true;
        }
      }
      seqShowDragPopup(ev.clientX, ev.clientY, (opts.label || '') + curVal);
    };
    const onUp = () => {
      el.removeEventListener('pointermove', onMove);
      el.removeEventListener('pointerup', onUp);
      el.removeEventListener('pointercancel', onUp);
      el.classList.remove('dragging');
      seqHideDragPopup();
      if (changed && opts.done) opts.done(curVal);
    };
    el.addEventListener('pointermove', onMove);
    el.addEventListener('pointerup', onUp);
    el.addEventListener('pointercancel', onUp);
  });
}

// ── Step cell: tap=toggle, vertical drag=probability ──
function seqStepPointerDown(e, idx) {
  const s = seq();
  if (idx >= s.trigger.steps) return;
  if (e.button !== 0) return;
  e.preventDefault();
  const cell = e.currentTarget;
  const startY = e.clientY;
  let dragged = false;
  const pid = e.pointerId;

  cell.setPointerCapture(pid);

  const onMove = (ev) => {
    if (Math.abs(ev.clientY - startY) > 5) dragged = true;
    if (!dragged) return;
    const rect = cell.getBoundingClientRect();
    const pct = 1 - Math.max(0, Math.min(1, (ev.clientY - rect.top) / rect.height));
    const val = Math.round(pct * 20) / 20; // 5% snap
    s.trigger.probability[idx] = val;
    cell.querySelector('.prob-fill').style.height = (val * 100) + '%';
    const pctText = Math.round(val * 100) + '%';
    cell.querySelector('.prob-label').textContent = pctText;
    seqShowDragPopup(ev.clientX, ev.clientY, pctText);
  };
  const onUp = () => {
    cell.removeEventListener('pointermove', onMove);
    cell.removeEventListener('pointerup', onUp);
    cell.removeEventListener('pointercancel', onUp);
    seqHideDragPopup();
    if (!dragged) {
      s.trigger.pattern[idx] = !s.trigger.pattern[idx];
      s.trigger.overrides.add(idx);
      seqSyncLinkedSteps(s);
      seqRenderTriggerGrid();
      seqRenderPitchGrid();
      seqRenderExprGrid();
      seqUpdatePatternDisplay();
      seqUpdatePolyInfo();
      seqRenderMiniOverview();
    }
  };
  cell.addEventListener('pointermove', onMove);
  cell.addEventListener('pointerup', onUp);
  cell.addEventListener('pointercancel', onUp);
}

// Double-click step cell → reset probability to 100%
function seqStepDblClick(idx) {
  const s = seq();
  s.trigger.probability[idx] = 1.0;
  seqRenderTriggerGrid();
}

function seqCycleRatchet(idx) {
  const s = seq();
  const cur = s.trigger.ratchet[idx] ?? 1;
  s.trigger.ratchet[idx] = cur >= 4 ? 1 : cur + 1;
  seqRenderTriggerGrid();
}

function seqLoadEucPreset(name) {
  const p = SEQ_EUC_PRESETS[name];
  if (!p) return;
  const s = seq(), st = s.trigger;
  st.steps = p.steps; st.hits = p.hits; st.rotation = 0;
  st.overrides.clear();
  document.getElementById('seqTrigSteps').textContent = p.steps;
  document.getElementById('seqTrigHits').textContent = p.hits;
  document.getElementById('seqTrigRot').textContent = '0';
  st.pattern = seqEuclidean(p.steps, p.hits, 0);
  seqSyncLinkedSteps(s);
  seqRenderTriggerGrid();
  seqUpdatePatternDisplay();
  seqUpdatePolyInfo();
  seqRenderMiniOverview();
  document.getElementById('seqEucPresetSel').value = name;
}

// ── Pitch lane ──
function seqUpdatePitchSteps() {
  const s = seq();
  if (s.linked) return; // steps locked by link
  s.pitch.steps = Math.max(1, Math.min(16, s.pitch.steps));
  const el = document.getElementById('seqPitchSteps');
  if (el) el.textContent = s.pitch.steps;
  seqRenderPitchGrid();
  seqUpdatePolyInfo();
}

function seqApplyPitchPreset(name) {
  const s = seq();
  const presets = s.pitch.mode === 'notes' ? SEQ_PITCH_PRESETS_NOTES : SEQ_PITCH_PRESETS;
  const p = presets[name];
  let offsets;
  if (s.pitch.mode === 'notes') {
    offsets = p ? [...p] : Array.from({ length: s.pitch.steps }, () => Math.floor(s.rng() * 8));
  } else {
    offsets = p ? [...p] : Array.from({ length: s.pitch.steps }, () => Math.floor(s.rng() * 25) - 12);
  }
  s.pitch.steps = offsets.length;
  document.getElementById('seqPitchSteps').value = offsets.length;
  for (let i = 0; i < 16; i++) s.pitch.offsets[i] = offsets[i] ?? 0;
  seqRenderPitchGrid();
  seqUpdatePolyInfo();
}

// ── Pitch bar drag (bipolar for semitones, positive for notes) ──
function seqPitchBarDrag(e, idx) {
  const s = seq();
  if (idx >= s.pitch.steps) return;
  if (e.button !== 0) return;
  e.preventDefault();
  const wrap = e.currentTarget;
  const isNotes = s.pitch.mode === 'notes';
  const pid = e.pointerId;
  wrap.setPointerCapture(pid);

  const onMove = (ev) => {
    const rect = wrap.getBoundingClientRect();
    const pct = 1 - Math.max(0, Math.min(1, (ev.clientY - rect.top) / rect.height));
    const val = isNotes ? Math.round(pct * 14) : Math.round((pct - 0.5) * 48);
    s.pitch.offsets[idx] = val;
    seqUpdatePitchBarDisplay(wrap, val, isNotes, s);
    const label = isNotes ? 'deg ' + val : (val >= 0 ? '+' : '') + val + ' st';
    seqShowDragPopup(ev.clientX, ev.clientY, label);
  };
  const onUp = () => {
    wrap.removeEventListener('pointermove', onMove);
    wrap.removeEventListener('pointerup', onUp);
    wrap.removeEventListener('pointercancel', onUp);
    seqHideDragPopup();
  };
  onMove(e);
  wrap.addEventListener('pointermove', onMove);
  wrap.addEventListener('pointerup', onUp);
  wrap.addEventListener('pointercancel', onUp);
}

function seqPitchBarDblClick(idx) {
  const s = seq();
  s.pitch.offsets[idx] = 0;
  seqRenderPitchGrid();
}

function seqUpdatePitchBarDisplay(wrap, val, isNotes, s) {
  const bar = wrap.querySelector('.pitch-bar');
  const label = wrap.querySelector('.pitch-val');
  const noteEl = wrap.parentElement.querySelector('.seq-pitch-note-name');
  if (isNotes) {
    const pct = Math.min(1, val / 14);
    bar.style.bottom = '0';
    bar.style.top = (100 - pct * 100) + '%';
    bar.style.height = (pct * 100) + '%';
    label.textContent = val;
    label.style.top = '2px';
    if (noteEl) {
      const scale = SEQ_SCALES[s.pitch.scale] || SEQ_SCALES['Major'];
      const midi = s.pitch.root + seqScaleDegreeToSemitone(val, scale);
      noteEl.textContent = seqMidiToName(midi);
    }
  } else {
    const norm = (val + 24) / 48; // 0..1
    if (val >= 0) {
      const topPct = (1 - norm) * 100;
      bar.style.top = topPct + '%';
      bar.style.height = (norm * 100 - 50) + '%';
    } else {
      bar.style.top = '50%';
      bar.style.height = (50 - norm * 100) + '%';
    }
    label.textContent = (val >= 0 ? '+' : '') + val;
    label.style.top = val >= 0 ? '2px' : 'auto';
    label.style.bottom = val < 0 ? '2px' : 'auto';
    if (noteEl) noteEl.textContent = '';
  }
}

// ── Tonal controls ──
function seqSetPitchMode(mode) {
  const s = seq();
  s.pitch.mode = mode;
  // Reset offsets when switching modes
  if (mode === 'notes') {
    for (let i = 0; i < 16; i++) s.pitch.offsets[i] = Math.max(0, s.pitch.offsets[i]);
  }
  seqRenderBody();
}

function seqSetRoot(midi) {
  seq().pitch.root = midi;
  seqRenderPitchGrid();
}

function seqSetScale(name) {
  seq().pitch.scale = name;
  seqRenderPitchGrid();
}

// ── Expression lane ──
function seqUpdateExprSteps() {
  const s = seq();
  if (s.linked) return; // steps locked by link
  s.expression.steps = Math.max(1, Math.min(16, s.expression.steps));
  const el = document.getElementById('seqExprSteps');
  if (el) el.textContent = s.expression.steps;
  seqRenderExprGrid();
  seqUpdatePolyInfo();
}

// ── Lane collapse ──
function seqToggleLane(lane) {
  const s = seq();
  if (lane === 'pitch') {
    s.pitch.expanded = !s.pitch.expanded;
    document.getElementById('seqPitchBody').style.display = s.pitch.expanded ? '' : 'none';
    document.getElementById('seqPitchExpand').textContent = s.pitch.expanded ? '\u25be' : '\u25b8';
  } else if (lane === 'morph') {
    s.morph.expanded = !s.morph.expanded;
    document.getElementById('seqMorphBody').style.display = s.morph.expanded ? '' : 'none';
    document.getElementById('seqMorphExpand').textContent = s.morph.expanded ? '\u25be' : '\u25b8';
  } else if (lane === 'dist') {
    s.distance.expanded = !s.distance.expanded;
    document.getElementById('seqDistBody').style.display = s.distance.expanded ? '' : 'none';
    document.getElementById('seqDistExpand').textContent = s.distance.expanded ? '\u25be' : '\u25b8';
  } else {
    s.expression.expanded = !s.expression.expanded;
    document.getElementById('seqExprBody').style.display = s.expression.expanded ? '' : 'none';
    document.getElementById('seqExprExpand').textContent = s.expression.expanded ? '\u25be' : '\u25b8';
  }
}

// ── Display updates ──
function seqUpdateStepDisplay(s, step, isHit) {
  if (s.lastDisplayStep >= 0) {
    const prev = document.querySelector('#seqTrigGrid .seq-step-cell[data-step="' + s.lastDisplayStep + '"]');
    if (prev) prev.classList.remove('playing');
  }
  const el = document.querySelector('#seqTrigGrid .seq-step-cell[data-step="' + step + '"]');
  if (el) el.classList.add('playing');
  s.lastDisplayStep = step;
  seqUpdatePatternDisplay(step);
}

function seqUpdateMiniStep(s, step) {
  // Update mini-overview dot highlight
  const row = document.querySelector('.seq-mini-row[data-seq="' + s.id + '"]');
  if (!row) return;
  row.querySelectorAll('.dot-cur').forEach(d => d.classList.remove('dot-cur'));
  const dots = row.querySelectorAll('.seq-mini-dots span');
  if (dots[step]) dots[step].classList.add('dot-cur');
}

function seqUpdateOvStep(s, step) {
  const grid = document.getElementById('seqOvGrid' + s.id);
  if (!grid) return;
  grid.querySelectorAll('.seq-step-cell.playing').forEach(el => el.classList.remove('playing'));
  const el = grid.querySelector('.seq-step-cell[data-step="' + step + '"]');
  if (el) el.classList.add('playing');
}

function seqUpdatePatternDisplay(currentStep) {
  return;
}

function seqUpdatePolyInfo() {
  const d = document.getElementById('seqPolyInfo');
  if (!d) return;
  const s = seq();
  const hits = s.trigger.pattern.filter(x => x).length;
  const pLen = s.pitch.steps, eLen = s.expression.steps;
  const mLen = s.morph.enabled ? s.morph.steps : 0;
  let cycle = hits > 0 ? seqLCM(seqLCM(hits, pLen), eLen) : 0;
  if (mLen > 0 && cycle > 0) cycle = seqLCM(cycle, mLen);
  const src = getSeqActiveSources(s);
  const srcText = src.length === 0 ? 'none' : src.length === 1 ? src[0] : src.length + ' voices (random)';
  d.innerHTML =
    'Trig <span class="hl">' + hits + '</span> hits \u00d7 Pitch <span class="hl">' + pLen +
    '</span> \u00d7 Expr <span class="hl">' + eLen + '</span>' +
    (mLen > 0 ? ' \u00d7 Morph <span class="hl">' + mLen + '</span>' : '') +
    ' = <span class="hl">' + cycle +
    '</span> hit cycle \u00a0|\u00a0 Source: <span class="hl">' + srcText + '</span>';
}

// ════════════════════════════════════════════════════════
// RENDER FUNCTIONS
// ════════════════════════════════════════════════════════

// ── Tab Bar ──
function seqRenderTabBar() {
  const bar = document.getElementById('seqTabBar');
  bar.innerHTML = '';
  sequencers.forEach((s, i) => {
    const tab = document.createElement('div');
    tab.className = 'seq-tab' + (i === seqActiveTab ? ' active' : '');
    tab.style.setProperty('--sc', s.color);
    tab.onclick = () => seqSwitchTab(i);
    tab.innerHTML =
      '<span>' + s.name + '</span>' +
      '<span class="seq-tab-ms">' +
        '<button class="mute-btn' + (s.muted ? ' on' : '') + '" onclick="seqToggleMute(' + i + ',event)">M</button>' +
        '<button class="solo-btn' + (s.solo ? ' on' : '') + '" onclick="seqToggleSolo(' + i + ',event)">S</button>' +
      '</span>';
    bar.appendChild(tab);
  });
}

// ── Full Body (active tab) ──
function seqRenderBody() {
  const body = document.getElementById('seqBody');
  const s = seq();
  body.style.setProperty('--sc', s.color);

  const isNotes = s.pitch.mode === 'notes';
  const pitchTitle = isNotes ? '\u266a PITCH (tonal — A=432Hz)' : '\u266a PITCH (semitone offsets)';

  // Root note options
  let rootOpts = '';
  for (let m = 24; m <= 96; m++) {
    const sel = m === s.pitch.root ? ' selected' : '';
    rootOpts += '<option value="' + m + '"' + sel + '>' + seqMidiToName(m) + '</option>';
  }

  // Scale options
  let scaleOpts = '';
  for (const name of Object.keys(SEQ_SCALES)) {
    const sel = name === s.pitch.scale ? ' selected' : '';
    scaleOpts += '<option value="' + name + '"' + sel + '>' + name + '</option>';
  }

  // Pitch presets dropdown
  const pitchPresets = isNotes ? SEQ_PITCH_PRESETS_NOTES : SEQ_PITCH_PRESETS;
  let pitchPresetOpts = '<option value="">Presets\u2026</option>';
  for (const name of Object.keys(pitchPresets)) {
    pitchPresetOpts += '<option value="' + name + '">' + name + '</option>';
  }

  // Euc preset dropdown
  let eucOpts = '<option value="">Pattern\u2026</option>';
  for (const name of Object.keys(SEQ_EUC_PRESETS)) {
    eucOpts += '<option value="' + name + '">' + name + '</option>';
  }

  body.innerHTML =
    // Sources
    '<div class="seq-sources" id="seqSources"></div>' +
    // Per-seq controls: clock div, swing
    '<div class="seq-per-controls">' +
      '<label>Clock <select id="seqClockDiv">' +
        '<option value="1/4"' + (s.clockDiv === '1/4' ? ' selected' : '') + '>1/4</option>' +
        '<option value="1/8"' + (s.clockDiv === '1/8' ? ' selected' : '') + '>1/8</option>' +
        '<option value="1/16"' + (s.clockDiv === '1/16' ? ' selected' : '') + '>1/16</option>' +
        '<option value="1/8T"' + (s.clockDiv === '1/8T' ? ' selected' : '') + '>1/8T</option>' +
      '</select></label>' +
      '<label>Swing <input type="range" id="seqSwing" min="0" max="0.75" step="0.05" value="' + s.swing + '" style="width:70px;height:24px;accent-color:' + s.color + '"> <span id="seqSwingVal" style="font-size:0.75rem;color:' + s.color + ';min-width:24px">' + Math.round(s.swing * 100) + '%</span></label>' +
      '<button id="seqLinkBtn" class="seq-link-btn' + (s.linked ? ' on' : '') + '" onclick="seqToggleLink()">Link</button>' +
      '<button id="seqEvolveBtn" class="seq-evolve-btn' + (s.evolve.enabled ? ' on' : '') + '" onclick="seqToggleEvolve()">Evolve</button>' +
    '</div>' +
    // Evolve panel
    '<div class="seq-evolve-panel' + (s.evolve.enabled ? ' open' : '') + '" id="seqEvolvePanel">' +
      '<div class="seq-evolve-row">' +
        '<span class="seq-drag-num-label">Every</span><span class="seq-drag-num" id="seqEvolveEvery" style="min-width:36px;padding:4px 8px">' + s.evolve.everyBars + '</span><span class="seq-drag-num-label" style="margin-left:2px">bars</span>' +
        '<label>Intensity <input type="range" id="seqEvolveIntensity" min="0" max="100" step="5" value="' + s.evolve.intensity + '"> <span id="seqEvolveIntVal" style="font-size:0.7rem;color:#a855f7;min-width:28px">' + s.evolve.intensity + '%</span></label>' +
        '<button onclick="seqResetEvolve()" style="font-size:0.7rem;padding:8px 14px;background:rgba(255,255,255,0.08);border:none;color:#888;border-radius:6px;cursor:pointer;min-height:36px">Reset</button>' +
      '</div>' +
      '<div class="seq-evolve-checks" id="seqEvolveChecks">' +
        '<label><input type="checkbox" data-m="rotateDrift"' + (s.evolve.methods.rotateDrift ? ' checked' : '') + '> Rotate</label>' +
        '<label><input type="checkbox" data-m="velocityBreath"' + (s.evolve.methods.velocityBreath ? ' checked' : '') + '> Velocity</label>' +
        '<label><input type="checkbox" data-m="swingDrift"' + (s.evolve.methods.swingDrift ? ' checked' : '') + '> Swing</label>' +
        '<label><input type="checkbox" data-m="probDrift"' + (s.evolve.methods.probDrift ? ' checked' : '') + '> Probability</label>' +
        '<label><input type="checkbox" data-m="morphDrift"' + (s.evolve.methods.morphDrift ? ' checked' : '') + '> Morph</label>' +
        '<label><input type="checkbox" data-m="ghostNotes"' + (s.evolve.methods.ghostNotes ? ' checked' : '') + '> Ghosts</label>' +
        '<label><input type="checkbox" data-m="ratchetSpray"' + (s.evolve.methods.ratchetSpray ? ' checked' : '') + '> Ratchet</label>' +
        '<label><input type="checkbox" data-m="hitDrift"' + (s.evolve.methods.hitDrift ? ' checked' : '') + '> Density</label>' +
        '<label><input type="checkbox" data-m="pitchWalk"' + (s.evolve.methods.pitchWalk ? ' checked' : '') + '> Pitch</label>' +
      '</div>' +
    '</div>' +
    // Trigger lane
    '<div class="seq-lane seq-lane-trigger">' +
      '<div class="seq-lane-header">' +
        '<span class="seq-lane-title">\u25cf TRIGGER (Euclidean)</span>' +
        '<div class="seq-lane-controls">' +
          '<button class="seq-lane-enable-btn' + (s.trigger.enabled ? ' on' : '') + '" id="seqTrigEnableBtn" onclick="event.stopPropagation();seqToggleLaneEnabled(\'trigger\')">' + (s.trigger.enabled ? 'On' : 'Off') + '</button>' +
          '<span class="seq-drag-num-label">Steps</span><span class="seq-drag-num" id="seqTrigSteps">' + s.trigger.steps + '</span>' +
          '<span class="seq-drag-num-label">Hits</span><span class="seq-drag-num" id="seqTrigHits">' + s.trigger.hits + '</span>' +
          '<label>Rot <span style="display:flex;gap:2px;align-items:center">' +
            '<button onclick="seqRotate(1)">\u2190</button>' +
            '<span id="seqTrigRot" style="min-width:20px;text-align:center;font-size:0.85rem;color:' + s.color + '">' + s.trigger.rotation + '</span>' +
            '<button onclick="seqRotate(-1)">\u2192</button>' +
          '</span></label>' +
          '<select id="seqEucPresetSel" style="width:80px" onchange="if(this.value)seqLoadEucPreset(this.value);this.value=\'\'">' + eucOpts + '</select>' +
        '</div>' +
      '</div>' +
      '<div class="seq-lane-body">' +
        '<div class="seq-step-grid" id="seqTrigGrid"></div>' +
        '<div style="font-size:0.65rem;color:#555;margin:4px 0 0;text-align:center;line-height:1.4">tap=toggle \u2502 drag\u2195=probability \u2502 dbl-tap=reset \u2502 tap ratchet below</div>' +
      '</div>' +
    '</div>' +
    // Pitch lane
    '<div class="seq-lane seq-lane-pitch">' +
      '<div class="seq-lane-header" onclick="seqToggleLane(\'pitch\')">' +
        '<span class="seq-lane-title">' + pitchTitle + '</span>' +
        '<div class="seq-lane-controls">' +
          '<button class="seq-lane-enable-btn' + (s.pitch.enabled ? ' on' : '') + '" id="seqPitchEnableBtn" onclick="event.stopPropagation();seqToggleLaneEnabled(\'pitch\')">' + (s.pitch.enabled ? 'On' : 'Off') + '</button>' +
          '<span class="seq-drag-num-label">Steps</span><span class="seq-drag-num' + (s.linked ? ' disabled" style="opacity:0.4;pointer-events:none' : '') + '" id="seqPitchSteps">' + s.pitch.steps + '</span>' +
          '<span class="seq-lane-expand" id="seqPitchExpand">' + (s.pitch.expanded ? '\u25be' : '\u25b8') + '</span>' +
        '</div>' +
      '</div>' +
      '<div class="seq-lane-body" id="seqPitchBody" style="display:' + (s.pitch.expanded ? '' : 'none') + '">' +
        // Tonal controls row
        '<div class="seq-per-controls" style="margin-bottom:4px">' +
          '<label style="gap:3px">Mode <select id="seqPitchMode" onchange="seqSetPitchMode(this.value)">' +
            '<option value="semitones"' + (!isNotes ? ' selected' : '') + '>Semitones</option>' +
            '<option value="notes"' + (isNotes ? ' selected' : '') + '>Notes (tonal)</option>' +
          '</select></label>' +
          (isNotes ? (
            '<label>Root <select id="seqPitchRoot" onchange="seqSetRoot(+this.value)">' + rootOpts + '</select></label>' +
            '<label>Scale <select id="seqPitchScale" onchange="seqSetScale(this.value)">' + scaleOpts + '</select></label>'
          ) : '') +
          '<select id="seqPitchPresetSel" style="width:72px" onchange="if(this.value)seqApplyPitchPreset(this.value);this.value=\'\'">' + pitchPresetOpts + '</select>' +
        '</div>' +
        '<div class="seq-step-grid" id="seqPitchGrid"></div>' +
      '</div>' +
    '</div>' +
    // Expression lane
    '<div class="seq-lane seq-lane-expr">' +
      '<div class="seq-lane-header" onclick="seqToggleLane(\'expr\')">' +
        '<span class="seq-lane-title">\u25c6 EXPRESSION (velocity)</span>' +
        '<div class="seq-lane-controls">' +
          '<button class="seq-lane-enable-btn' + (s.expression.enabled ? ' on' : '') + '" id="seqExprEnableBtn" onclick="event.stopPropagation();seqToggleLaneEnabled(\'expr\')">' + (s.expression.enabled ? 'On' : 'Off') + '</button>' +
          '<span class="seq-drag-num-label">Steps</span><span class="seq-drag-num' + (s.linked ? ' disabled" style="opacity:0.4;pointer-events:none' : '') + '" id="seqExprSteps">' + s.expression.steps + '</span>' +
          '<span class="seq-lane-expand" id="seqExprExpand">' + (s.expression.expanded ? '\u25be' : '\u25b8') + '</span>' +
        '</div>' +
      '</div>' +
      '<div class="seq-lane-body" id="seqExprBody" style="display:' + (s.expression.expanded ? '' : 'none') + '">' +
        '<div class="seq-step-grid" id="seqExprGrid"></div>' +
      '</div>' +
    '</div>' +
    // Preset Morph lane
    '<div class="seq-lane seq-lane-morph">' +
      '<div class="seq-lane-header" onclick="seqToggleLane(\'morph\')">' +
        '<span class="seq-lane-title">\u25c8 PRESET MORPH</span>' +
        '<div class="seq-lane-controls">' +
          '<button class="seq-lane-enable-btn' + (s.morph.enabled ? ' on' : '') + '" id="seqMorphEnableBtn" onclick="event.stopPropagation();seqToggleLaneEnabled(\'morph\')">' + (s.morph.enabled ? 'On' : 'Off') + '</button>' +
          '<span class="seq-drag-num-label">Steps</span><span class="seq-drag-num" id="seqMorphSteps">' + s.morph.steps + '</span>' +
          '<span class="seq-lane-expand" id="seqMorphExpand">' + (s.morph.expanded ? '\u25be' : '\u25b8') + '</span>' +
        '</div>' +
      '</div>' +
      '<div class="seq-lane-body" id="seqMorphBody" style="display:' + (s.morph.expanded ? '' : 'none') + '">' +
        '<div class="seq-step-grid" id="seqMorphGrid"></div>' +
      '</div>' +
    '</div>' +
    // Distance lane
    '<div class="seq-lane seq-lane-dist">' +
      '<div class="seq-lane-header" onclick="seqToggleLane(\'dist\')">' +
        '<span class="seq-lane-title">\u25c9 DISTANCE</span>' +
        '<div class="seq-lane-controls">' +
          '<button class="seq-lane-enable-btn' + (s.distance.enabled ? ' on' : '') + '" id="seqDistEnableBtn" onclick="event.stopPropagation();seqToggleLaneEnabled(\'dist\')">' + (s.distance.enabled ? 'On' : 'Off') + '</button>' +
          '<span class="seq-drag-num-label">Steps</span><span class="seq-drag-num" id="seqDistSteps">' + s.distance.steps + '</span>' +
          '<span class="seq-lane-expand" id="seqDistExpand">' + (s.distance.expanded ? '\u25be' : '\u25b8') + '</span>' +
        '</div>' +
      '</div>' +
      '<div class="seq-lane-body" id="seqDistBody" style="display:' + (s.distance.expanded ? '' : 'none') + '">' +
        '<div class="seq-step-grid" id="seqDistGrid"></div>' +
      '</div>' +
    '</div>' +
    // Poly info
    '<div class="seq-poly-info" id="seqPolyInfo">\u2014</div>';

  // Bind per-seq controls
  document.getElementById('seqClockDiv').addEventListener('change', function() { s.clockDiv = this.value; });
  document.getElementById('seqSwing').addEventListener('input', function() {
    s.swing = +this.value;
    document.getElementById('seqSwingVal').textContent = Math.round(s.swing * 100) + '%';
  });

  // Evolve panel bindings
  const evolveEvery = document.getElementById('seqEvolveEvery');
  if (evolveEvery) {
    seqDragNumBind(evolveEvery, {
      min: 1, max: () => 32, label: 'Every: ',
      get: () => s.evolve.everyBars,
      set: (v) => { s.evolve.everyBars = v; }
    });
  }
  const evolveIntensity = document.getElementById('seqEvolveIntensity');
  if (evolveIntensity) evolveIntensity.addEventListener('input', function() {
    s.evolve.intensity = +this.value;
    document.getElementById('seqEvolveIntVal').textContent = this.value + '%';
    // Auto-update method checkboxes based on intensity
    const auto = seqEvolveIntensityToMethods(s.evolve.intensity);
    Object.assign(s.evolve.methods, auto);
    document.querySelectorAll('#seqEvolveChecks input[type=checkbox]').forEach(cb => {
      cb.checked = s.evolve.methods[cb.dataset.m] || false;
    });
  });
  document.querySelectorAll('#seqEvolveChecks input[type=checkbox]').forEach(cb => {
    cb.addEventListener('change', function() { s.evolve.methods[this.dataset.m] = this.checked; });
  });

  // Bind drag-number widgets for Steps / Hits
  seqDragNumBind(document.getElementById('seqTrigSteps'), {
    min: 2, max: () => 16, label: 'Steps: ',
    get: () => s.trigger.steps,
    set: (v) => { s.trigger.steps = v; s.trigger.hits = Math.min(s.trigger.hits, v); seqUpdateEuclidean(); },
    done: () => { seqRenderBody(); }
  });
  seqDragNumBind(document.getElementById('seqTrigHits'), {
    min: 0, max: () => s.trigger.steps, label: 'Hits: ',
    get: () => s.trigger.hits,
    set: (v) => { s.trigger.hits = v; seqUpdateEuclidean(); }
  });
  const pitchStepsEl = document.getElementById('seqPitchSteps');
  if (pitchStepsEl && !s.linked) {
    seqDragNumBind(pitchStepsEl, {
      min: 1, max: () => 16, label: 'Steps: ',
      get: () => s.pitch.steps,
      set: (v) => { s.pitch.steps = v; seqRenderPitchGrid(); }
    });
  }
  const exprStepsEl = document.getElementById('seqExprSteps');
  if (exprStepsEl && !s.linked) {
    seqDragNumBind(exprStepsEl, {
      min: 1, max: () => 16, label: 'Steps: ',
      get: () => s.expression.steps,
      set: (v) => { s.expression.steps = v; seqRenderExprGrid(); }
    });
  }
  seqDragNumBind(document.getElementById('seqMorphSteps'), {
    min: 1, max: () => 16, label: 'Steps: ',
    get: () => s.morph.steps,
    set: (v) => { s.morph.steps = v; seqRenderMorphGrid(); }
  });
  seqDragNumBind(document.getElementById('seqDistSteps'), {
    min: 1, max: () => 16, label: 'Steps: ',
    get: () => s.distance.steps,
    set: (v) => { s.distance.steps = v; seqRenderDistGrid(); }
  });

  // Render sub-components
  seqRenderSources();
  seqRenderTriggerGrid();
  seqRenderPitchGrid();
  seqRenderExprGrid();
  seqRenderMorphGrid();
  seqRenderDistGrid();
  seqUpdatePatternDisplay();
  seqUpdatePolyInfo();
}

// ── Sources ──
function seqRenderSources() {
  const c = document.getElementById('seqSources');
  const s = seq();
  c.innerHTML = '<span class="seq-sources-label">Sources</span>';
  const colors = { sub: '#ef4444', kick: '#f97316', click: '#eab308', beepHi: '#22c55e', beepLo: '#06b6d4', noise: '#8b5cf6', membrane: '#e11d48', freeze: '#0ea5e9' };
  const labels = { sub: 'Sub', kick: 'Kick', click: 'Click', beepHi: 'BeepHi', beepLo: 'BeepLo', noise: 'Noise', membrane: 'Membr', freeze: 'Freeze' };
  for (const [v, color] of Object.entries(colors)) {
    const lbl = document.createElement('label');
    lbl.className = 'seq-source-toggle' + (s.sources[v] ? ' active' : '');
    lbl.style.setProperty('--vc', color);
    lbl.innerHTML = '<input type="checkbox" ' + (s.sources[v] ? 'checked' : '') + '><span>' + labels[v] + '</span>';
    lbl.querySelector('input').addEventListener('change', function() {
      s.sources[v] = this.checked;
      lbl.classList.toggle('active', this.checked);
      seqUpdatePolyInfo();
      seqRenderMiniOverview();
    });
    c.appendChild(lbl);
  }
}

// ── Trigger Grid (step cells with integrated prob + ratchet hash lines) ──
function seqRenderTriggerGrid() {
  const g = document.getElementById('seqTrigGrid');
  if (!g) return;
  const s = seq();
  g.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    const inRange = i < s.trigger.steps;
    const active = inRange && s.trigger.pattern[i];
    const ratch = s.trigger.ratchet[i] ?? 1;
    const prob = s.trigger.probability[i] ?? 1.0;
    const probPct = Math.round(prob * 100);
    const step = document.createElement('div');
    step.className = 'seq-step';

    // Compact step numbers: only show at beat heads (1, 5, 9, 13)
    const showNum = (i % 4 === 0);
    const numLabel = showNum ? (i + 1) : '';

    const cellCls = 'seq-step-cell' + (active ? ' active' : '') + (!inRange ? ' inactive' : '');

    // Ratchet hash lines
    let ratchHtml = '';
    for (let r = 0; r < ratch; r++) ratchHtml += '<span class="ratch-line"></span>';
    const ratchCls = 'seq-step-ratchet' + (ratch > 1 ? ' multi r' + ratch : '');

    step.innerHTML =
      '<div class="seq-step-num">' + numLabel + '</div>' +
      '<div class="' + cellCls + '" data-step="' + i + '" style="touch-action:none">' +
        '<div class="prob-fill" style="height:' + (prob * 100) + '%"></div>' +
        '<div class="prob-label">' + probPct + '%</div>' +
      '</div>' +
      '<div class="' + ratchCls + '" title="Ratchet: ' + ratch + 'x" style="' + (!inRange ? 'opacity:0.25' : '') + '">' +
        ratchHtml +
      '</div>';

    if (inRange) {
      const cell = step.querySelector('.seq-step-cell');
      cell.addEventListener('pointerdown', (e) => seqStepPointerDown(e, i));
      cell.addEventListener('dblclick', () => seqStepDblClick(i));
      step.querySelector('.seq-step-ratchet').addEventListener('click', () => seqCycleRatchet(i));
    }
    g.appendChild(step);
  }
}

// ── Pitch Grid (bipolar drag bars) ──
function seqRenderPitchGrid() {
  const g = document.getElementById('seqPitchGrid');
  if (!g) return;
  const s = seq();
  const isNotes = s.pitch.mode === 'notes';
  g.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    const inRange = i < s.pitch.steps;
    const off = s.pitch.offsets[i] ?? 0;
    const step = document.createElement('div');
    step.className = 'seq-step';

    // Compact step numbers
    const showNum = (i % 4 === 0);
    const numLabel = showNum ? (i + 1) : '';

    // Calculate bar position
    let barStyle = '';
    let valText = '';
    if (isNotes) {
      const pct = Math.min(1, off / 14);
      barStyle = 'bottom:0;top:' + (100 - pct * 100) + '%;height:' + (pct * 100) + '%';
      valText = '' + off;
    } else {
      const norm = (off + 24) / 48;
      if (off >= 0) {
        barStyle = 'top:' + ((1 - norm) * 100) + '%;height:' + (norm * 100 - 50) + '%';
      } else {
        barStyle = 'top:50%;height:' + (50 - norm * 100) + '%';
      }
      valText = (off >= 0 ? '+' : '') + off;
    }

    // Note name
    let noteName = '';
    if (isNotes) {
      const scale = SEQ_SCALES[s.pitch.scale] || SEQ_SCALES['Major'];
      const midi = s.pitch.root + seqScaleDegreeToSemitone(off, scale);
      noteName = seqMidiToName(midi);
    }

    step.innerHTML =
      '<div class="seq-step-num" style="color:#ff6b81">' + numLabel + '</div>' +
      '<div class="seq-pitch-bar-wrap' + (!inRange ? ' inactive' : '') + '" data-idx="' + i + '">' +
        (isNotes ? '' : '<div class="pitch-center"></div>') +
        '<div class="pitch-bar" style="' + barStyle + '"></div>' +
        '<div class="pitch-val" style="' + (off >= 0 || isNotes ? 'top:2px' : 'bottom:2px') + '">' + valText + '</div>' +
      '</div>' +
      '<div class="seq-pitch-note-name">' + noteName + '</div>';

    if (inRange) {
      const idx = i;
      const wrap = step.querySelector('.seq-pitch-bar-wrap');
      wrap.addEventListener('pointerdown', (e) => seqPitchBarDrag(e, idx));
      wrap.addEventListener('dblclick', () => seqPitchBarDblClick(idx));
    }
    g.appendChild(step);
  }
}

// ── Expression Grid (with double-click reset) ──
function seqRenderExprGrid() {
  const g = document.getElementById('seqExprGrid');
  if (!g) return;
  const s = seq();
  g.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    const inRange = i < s.expression.steps;
    const vel = s.expression.velocities[i] ?? 1.0;
    const pct = Math.round(vel * 100);
    const step = document.createElement('div');
    step.className = 'seq-step';

    // Compact step numbers
    const showNum = (i % 4 === 0);
    const numLabel = showNum ? (i + 1) : '';

    step.innerHTML =
      '<div class="seq-step-num" style="color:#ffa502">' + numLabel + '</div>' +
      '<div class="seq-vel-bar-wrap' + (!inRange ? ' inactive' : '') + '" data-idx="' + i + '">' +
        '<div class="seq-vel-bar" style="height:' + (vel * 100) + '%"></div>' +
        '<div class="seq-vel-label">' + pct + '%</div>' +
      '</div>';
    if (inRange) {
      const idx = i;
      const wrap = step.querySelector('.seq-vel-bar-wrap');
      wrap.addEventListener('pointerdown', (e) => seqVelDrag(e, idx));
      wrap.addEventListener('dblclick', () => {
        s.expression.velocities[idx] = 1.0;
        seqRenderExprGrid();
      });
    }
    g.appendChild(step);
  }
}

// ── Velocity drag handler ──
function seqVelDrag(e, idx) {
  const s = seq();
  if (idx >= s.expression.steps) return;
  if (e.button !== 0) return;
  e.preventDefault();
  const wrap = e.currentTarget;
  const pid = e.pointerId;
  wrap.setPointerCapture(pid);

  const onMove = (ev) => {
    const rect = wrap.getBoundingClientRect();
    const pct = 1 - Math.max(0, Math.min(1, (ev.clientY - rect.top) / rect.height));
    const val = Math.round(pct * 20) / 20;
    s.expression.velocities[idx] = val;
    const pctText = Math.round(val * 100) + '%';
    wrap.querySelector('.seq-vel-bar').style.height = (val * 100) + '%';
    wrap.querySelector('.seq-vel-label').textContent = pctText;
    seqShowDragPopup(ev.clientX, ev.clientY, pctText);
  };
  const onUp = () => {
    wrap.removeEventListener('pointermove', onMove);
    wrap.removeEventListener('pointerup', onUp);
    wrap.removeEventListener('pointercancel', onUp);
    seqHideDragPopup();
  };
  onMove(e);
  wrap.addEventListener('pointermove', onMove);
  wrap.addEventListener('pointerup', onUp);
  wrap.addEventListener('pointercancel', onUp);
}

// ── Preset Morph Grid (bipolar bars: top=A, center=50/50, bottom=B) ──
function seqRenderMorphGrid() {
  const g = document.getElementById('seqMorphGrid');
  if (!g) return;
  const s = seq();
  g.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    const inRange = i < s.morph.steps;
    const val = s.morph.values[i] ?? 0.5;
    const step = document.createElement('div');
    step.className = 'seq-step';

    const showNum = (i % 4 === 0);
    const numLabel = showNum ? (i + 1) : '';

    const wrap = document.createElement('div');
    step.innerHTML = '<div class="seq-step-num" style="color:#c084fc">' + numLabel + '</div>';

    const bw = document.createElement('div');
    bw.className = 'seq-morph-bar-wrap' + (!inRange ? ' inactive' : '');
    bw.dataset.idx = i;
    seqUpdateMorphBarDisplay(bw, val);

    if (inRange) {
      const idx = i;
      bw.addEventListener('pointerdown', (e) => seqMorphBarDrag(e, idx));
      bw.addEventListener('dblclick', () => seqMorphBarDblClick(idx));
    }
    step.appendChild(bw);
    g.appendChild(step);
  }
}

function seqUpdateMorphBarDisplay(wrap, val) {
  // val: 1.0 = Preset A (top), 0.0 = Preset B (bottom), 0.5 = center
  let barStyle = '';
  if (val >= 0.5) {
    // Bar extends upward from center (max 50% height)
    const heightPct = (val - 0.5) * 100;
    const topPct = 50 - heightPct;
    barStyle = 'top:' + topPct + '%;height:' + heightPct + '%';
  } else {
    // Bar extends downward from center (max 50% height)
    const heightPct = (0.5 - val) * 100;
    barStyle = 'top:50%;height:' + heightPct + '%';
  }
  const labelText = val >= 0.5 ? Math.round((val - 0.5) * 200) + '% A' : Math.round((0.5 - val) * 200) + '% B';
  wrap.innerHTML =
    '<div class="morph-center"></div>' +
    '<div class="morph-bar" style="' + barStyle + '"></div>' +
    '<div class="morph-val" style="' + (val >= 0.5 ? 'top:2px' : 'bottom:2px') + '">' + labelText + '</div>' +
    '<div class="morph-label-a">A</div>' +
    '<div class="morph-label-b">B</div>';
}

function seqMorphBarDrag(e, idx) {
  const s = seq();
  if (idx >= s.morph.steps) return;
  if (e.button !== 0) return;
  e.preventDefault();
  const wrap = e.currentTarget;
  const pid = e.pointerId;
  wrap.setPointerCapture(pid);

  const onMove = (ev) => {
    const rect = wrap.getBoundingClientRect();
    // Top = 1.0 (A), Bottom = 0.0 (B)
    const raw = 1 - Math.max(0, Math.min(1, (ev.clientY - rect.top) / rect.height));
    const val = Math.round(raw * 20) / 20; // snap to 5% increments
    s.morph.values[idx] = val;
    seqUpdateMorphBarDisplay(wrap, val);
    const labelText = val >= 0.5 ? Math.round((val - 0.5) * 200) + '% A' : Math.round((0.5 - val) * 200) + '% B';
    seqShowDragPopup(ev.clientX, ev.clientY, labelText);
  };
  const onUp = () => {
    wrap.removeEventListener('pointermove', onMove);
    wrap.removeEventListener('pointerup', onUp);
    wrap.removeEventListener('pointercancel', onUp);
    seqHideDragPopup();
  };
  onMove(e);
  wrap.addEventListener('pointermove', onMove);
  wrap.addEventListener('pointerup', onUp);
  wrap.addEventListener('pointercancel', onUp);
}

function seqMorphBarDblClick(idx) {
  const s = seq();
  s.morph.values[idx] = 1.0; // Reset to 100% Preset A
  seqRenderMorphGrid();
}

function seqToggleMorphEnabled(checked) {
  const s = seq();
  s.morph.enabled = checked;
}

// ── Distance Grid (bipolar bars: top=1.0/max, center=0.5/default, bottom=0.0/min) ──
function seqRenderDistGrid() {
  const g = document.getElementById('seqDistGrid');
  if (!g) return;
  const s = seq();
  g.innerHTML = '';
  for (let i = 0; i < 16; i++) {
    const inRange = i < s.distance.steps;
    const val = s.distance.values[i] ?? 0.5;
    const step = document.createElement('div');
    step.className = 'seq-step';

    const showNum = (i % 4 === 0);
    const numLabel = showNum ? (i + 1) : '';

    step.innerHTML = '<div class="seq-step-num" style="color:#2dd4bf">' + numLabel + '</div>';

    const bw = document.createElement('div');
    bw.className = 'seq-dist-bar-wrap' + (!inRange ? ' inactive' : '');
    bw.dataset.idx = i;
    seqUpdateDistBarDisplay(bw, val);

    if (inRange) {
      const idx = i;
      bw.addEventListener('pointerdown', (e) => seqDistDrag(e, idx));
      bw.addEventListener('dblclick', () => seqDistBarDblClick(idx));
    }
    step.appendChild(bw);
    g.appendChild(step);
  }
}

function seqUpdateDistBarDisplay(wrap, val) {
  // val: 1.0 = max (top), 0.0 = min (bottom), 0.5 = center/default
  let barStyle = '';
  if (val >= 0.5) {
    const heightPct = (val - 0.5) * 100;
    const topPct = 50 - heightPct;
    barStyle = 'top:' + topPct + '%;height:' + heightPct + '%';
  } else {
    const heightPct = (0.5 - val) * 100;
    barStyle = 'top:50%;height:' + heightPct + '%';
  }
  const pct = Math.round(val * 100);
  wrap.innerHTML =
    '<div class="dist-center"></div>' +
    '<div class="dist-bar" style="' + barStyle + '"></div>' +
    '<div class="dist-val" style="' + (val >= 0.5 ? 'top:2px' : 'bottom:2px') + '">' + pct + '%</div>' +
    '<div class="dist-label-max">1</div>' +
    '<div class="dist-label-min">0</div>';
}

function seqDistBarDblClick(idx) {
  const s = seq();
  s.distance.values[idx] = 0.5; // Reset to 50% center/default
  seqRenderDistGrid();
}

// ── Distance drag handler (bipolar) ──
function seqDistDrag(e, idx) {
  const s = seq();
  if (idx >= s.distance.steps) return;
  if (e.button !== 0) return;
  e.preventDefault();
  const wrap = e.currentTarget;
  const pid = e.pointerId;
  wrap.setPointerCapture(pid);

  const onMove = (ev) => {
    const rect = wrap.getBoundingClientRect();
    // Top = 1.0 (max), Bottom = 0.0 (min)
    const raw = 1 - Math.max(0, Math.min(1, (ev.clientY - rect.top) / rect.height));
    const val = Math.round(raw * 20) / 20; // snap to 5% increments
    s.distance.values[idx] = val;
    seqUpdateDistBarDisplay(wrap, val);
    seqShowDragPopup(ev.clientX, ev.clientY, Math.round(val * 100) + '%');
  };
  const onUp = () => {
    wrap.removeEventListener('pointermove', onMove);
    wrap.removeEventListener('pointerup', onUp);
    wrap.removeEventListener('pointercancel', onUp);
    seqHideDragPopup();
  };
  onMove(e);
  wrap.addEventListener('pointermove', onMove);
  wrap.addEventListener('pointerup', onUp);
  wrap.addEventListener('pointercancel', onUp);
}

function seqUpdateDistSteps() {
  const s = seq();
  s.distance.steps = Math.max(1, Math.min(16, s.distance.steps));
  const el = document.getElementById('seqDistSteps');
  if (el) el.textContent = s.distance.steps;
  seqRenderDistGrid();
  seqUpdatePolyInfo();
}

function seqToggleLaneEnabled(lane) {
  const s = seq();
  if (lane === 'trigger') {
    s.trigger.enabled = !s.trigger.enabled;
    const btn = document.getElementById('seqTrigEnableBtn');
    if (btn) { btn.classList.toggle('on', s.trigger.enabled); btn.textContent = s.trigger.enabled ? 'On' : 'Off'; }
  } else if (lane === 'pitch') {
    s.pitch.enabled = !s.pitch.enabled;
    const btn = document.getElementById('seqPitchEnableBtn');
    if (btn) { btn.classList.toggle('on', s.pitch.enabled); btn.textContent = s.pitch.enabled ? 'On' : 'Off'; }
    if (s.pitch.enabled) {
      s.pitch.expanded = true;
      document.getElementById('seqPitchBody').style.display = '';
      document.getElementById('seqPitchExpand').textContent = '\u25be';
    } else {
      s.pitch.expanded = false;
      document.getElementById('seqPitchBody').style.display = 'none';
      document.getElementById('seqPitchExpand').textContent = '\u25b8';
    }
  } else if (lane === 'expr') {
    s.expression.enabled = !s.expression.enabled;
    const btn = document.getElementById('seqExprEnableBtn');
    if (btn) { btn.classList.toggle('on', s.expression.enabled); btn.textContent = s.expression.enabled ? 'On' : 'Off'; }
    if (s.expression.enabled) {
      s.expression.expanded = true;
      document.getElementById('seqExprBody').style.display = '';
      document.getElementById('seqExprExpand').textContent = '\u25be';
    } else {
      s.expression.expanded = false;
      document.getElementById('seqExprBody').style.display = 'none';
      document.getElementById('seqExprExpand').textContent = '\u25b8';
    }
  } else if (lane === 'morph') {
    const wasEnabled = s.morph.enabled;
    s.morph.enabled = !wasEnabled;
    const btn = document.getElementById('seqMorphEnableBtn');
    if (btn) { btn.classList.toggle('on', s.morph.enabled); btn.textContent = s.morph.enabled ? 'On' : 'Off'; }
    if (s.morph.enabled) {
      // Snapshot each voice's manual morph slider value before sequencer takes over
      s.morph.savedSliderValues = {};
      const voices = getSeqActiveSources(s);
      for (const v of voices) {
        const sl = document.getElementById('morph-' + v);
        if (sl) s.morph.savedSliderValues[v] = parseFloat(sl.value);
      }
      s.morph.expanded = true;
      document.getElementById('seqMorphBody').style.display = '';
      document.getElementById('seqMorphExpand').textContent = '\u25be';
    } else {
      // Restore manual morph slider values and re-apply morph for each voice
      if (s.morph.savedSliderValues) {
        for (const [v, val] of Object.entries(s.morph.savedSliderValues)) {
          const sl = document.getElementById('morph-' + v);
          if (sl) {
            sl.value = val;
            applyMorph(v);
          }
        }
        delete s.morph.savedSliderValues;
      }
      s.morph.expanded = false;
      document.getElementById('seqMorphBody').style.display = 'none';
      document.getElementById('seqMorphExpand').textContent = '\u25b8';
    }
  } else if (lane === 'dist') {
    s.distance.enabled = !s.distance.enabled;
    const btn = document.getElementById('seqDistEnableBtn');
    if (btn) { btn.classList.toggle('on', s.distance.enabled); btn.textContent = s.distance.enabled ? 'On' : 'Off'; }
    if (s.distance.enabled) {
      // Snapshot each voice's manual Distance slider value
      s.distance.savedSliderValues = {};
      const voices = getSeqActiveSources(s);
      const distKeys = { sub: 'drumSubDistance', kick: 'drumKickDistance', click: 'drumClickDistance', beepHi: 'drumBeepHiDistance', beepLo: 'drumBeepLoDistance', noise: 'drumNoiseDistance', membrane: 'drumMembraneDistance', freeze: 'drumFreezeDistance' };
      for (const v of voices) {
        const dk = distKeys[v];
        if (dk && state[dk] !== undefined) s.distance.savedSliderValues[v] = state[dk];
      }
      s.distance.expanded = true;
      document.getElementById('seqDistBody').style.display = '';
      document.getElementById('seqDistExpand').textContent = '\u25be';
    } else {
      // Restore manual Distance values
      if (s.distance.savedSliderValues) {
        const distKeys = { sub: 'drumSubDistance', kick: 'drumKickDistance', click: 'drumClickDistance', beepHi: 'drumBeepHiDistance', beepLo: 'drumBeepLoDistance', noise: 'drumNoiseDistance', membrane: 'drumMembraneDistance', freeze: 'drumFreezeDistance' };
        for (const [v, val] of Object.entries(s.distance.savedSliderValues)) {
          const dk = distKeys[v];
          if (dk) {
            state[dk] = val;
            const sl = document.querySelector('[data-key="' + dk + '"]');
            if (sl) { sl.value = val; }
          }
        }
        delete s.distance.savedSliderValues;
      }
      s.distance.expanded = false;
      document.getElementById('seqDistBody').style.display = 'none';
      document.getElementById('seqDistExpand').textContent = '\u25b8';
    }
  }
}

function seqUpdateMorphSteps() {
  const s = seq();
  s.morph.steps = Math.max(1, Math.min(16, s.morph.steps));
  const el = document.getElementById('seqMorphSteps');
  if (el) el.textContent = s.morph.steps;
  seqRenderMorphGrid();
  seqUpdatePolyInfo();
}

// ── Overview Mode (all 4 trigger grids) ──
function seqRenderOverview() {
  const c = document.getElementById('seqOverview');
  if (!c) return;
  c.innerHTML = '';

  sequencers.forEach((s, si) => {
    const row = document.createElement('div');
    row.className = 'seq-ov-row' + (s.muted ? ' ov-muted' : '');
    row.style.setProperty('--sc', s.color);
    row.dataset.seq = si;

    // Source names
    const src = getSeqActiveSources(s);
    const srcBrief = src.length === 0 ? 'no src' : src.length <= 3 ? src.join(', ') : src.length + ' voices';

    // Euc presets
    let eucOpts = '<option value="">Pat\u2026</option>';
    for (const name of Object.keys(SEQ_EUC_PRESETS)) {
      eucOpts += '<option value="' + name + '">' + name + '</option>';
    }

    // Header with inline controls
    const header = document.createElement('div');
    header.className = 'seq-ov-header';
    header.innerHTML =
      '<span class="seq-ov-name" onclick="seqSwitchTab(' + si + ')" title="Click to edit">' + s.name + '</span>' +
      '<span class="seq-ov-src">' + srcBrief + '</span>' +
      '<div class="seq-ov-controls">' +
        '<span class="seq-drag-num-label">S</span><span class="seq-drag-num" data-ctrl="steps" data-seq="' + si + '" style="min-width:36px;padding:4px 8px">' + s.trigger.steps + '</span>' +
        '<span class="seq-drag-num-label">H</span><span class="seq-drag-num" data-ctrl="hits" data-seq="' + si + '" style="min-width:36px;padding:4px 8px">' + s.trigger.hits + '</span>' +
        '<label>R<span style="display:flex;gap:2px;align-items:center">' +
          '<button data-ctrl="rotL" data-seq="' + si + '" style="width:32px;height:32px;font-size:0.8rem;line-height:32px;padding:0;border-radius:6px">\u2190</button>' +
          '<span style="font-size:0.75rem;color:' + s.color + ';min-width:14px;text-align:center">' + s.trigger.rotation + '</span>' +
          '<button data-ctrl="rotR" data-seq="' + si + '" style="width:32px;height:32px;font-size:0.8rem;line-height:32px;padding:0;border-radius:6px">\u2192</button>' +
        '</span></label>' +
        '<select data-ctrl="euc" data-seq="' + si + '" style="width:64px">' + eucOpts + '</select>' +
        '<select data-ctrl="clk" data-seq="' + si + '">' +
          '<option value="1/4"' + (s.clockDiv === '1/4' ? ' selected' : '') + '>1/4</option>' +
          '<option value="1/8"' + (s.clockDiv === '1/8' ? ' selected' : '') + '>1/8</option>' +
          '<option value="1/16"' + (s.clockDiv === '1/16' ? ' selected' : '') + '>1/16</option>' +
          '<option value="1/8T"' + (s.clockDiv === '1/8T' ? ' selected' : '') + '>1/8T</option>' +
        '</select>' +
        '<button class="ov-mute-btn' + (s.muted ? ' on' : '') + '" data-ctrl="mute" data-seq="' + si + '">M</button>' +
        '<button class="ov-solo-btn' + (s.solo ? ' on' : '') + '" data-ctrl="solo" data-seq="' + si + '">S</button>' +
      '</div>';
    row.appendChild(header);

    // Bind overview drag-num widgets for Steps / Hits
    header.querySelectorAll('.seq-drag-num[data-ctrl]').forEach(el => {
      const ctrl = el.dataset.ctrl;
      const idx = +el.dataset.seq;
      const sq = sequencers[idx];
      const applyOvEuc = () => {
        const newP = seqEuclidean(sq.trigger.steps, sq.trigger.hits, sq.trigger.rotation);
        for (let i = 0; i < sq.trigger.steps; i++) if (!sq.trigger.overrides.has(i)) sq.trigger.pattern[i] = newP[i];
        for (const oi of sq.trigger.overrides) if (oi >= sq.trigger.steps) sq.trigger.overrides.delete(oi);
        while (sq.trigger.pattern.length < sq.trigger.steps) sq.trigger.pattern.push(newP[sq.trigger.pattern.length] || false);
        sq.trigger.pattern = sq.trigger.pattern.slice(0, sq.trigger.steps);
        seqSyncLinkedSteps(sq);
      };
      if (ctrl === 'steps') {
        seqDragNumBind(el, {
          min: 2, max: () => 16, label: 'Steps: ',
          get: () => sq.trigger.steps,
          set: (v) => { sq.trigger.steps = v; sq.trigger.hits = Math.min(sq.trigger.hits, v); applyOvEuc(); },
          done: () => { seqRenderOverview(); }
        });
      } else if (ctrl === 'hits') {
        seqDragNumBind(el, {
          min: 0, max: () => sq.trigger.steps, label: 'Hits: ',
          get: () => sq.trigger.hits,
          set: (v) => { sq.trigger.hits = v; applyOvEuc(); },
          done: () => { seqRenderOverview(); }
        });
      }
    });
    header.querySelectorAll('select[data-ctrl]').forEach(sel => {
      sel.addEventListener('click', e => e.stopPropagation());
      sel.addEventListener('change', () => {
        const ctrl = sel.dataset.ctrl;
        const idx = +sel.dataset.seq;
        const sq = sequencers[idx];
        if (ctrl === 'euc' && sel.value) {
          const p = SEQ_EUC_PRESETS[sel.value];
          if (p) {
            sq.trigger.steps = p.steps; sq.trigger.hits = p.hits; sq.trigger.rotation = 0;
            sq.trigger.overrides.clear();
            sq.trigger.pattern = seqEuclidean(p.steps, p.hits, 0);
          }
          sel.value = '';
          seqSyncLinkedSteps(sq);
          seqRenderOverview();
        } else if (ctrl === 'clk') {
          sq.clockDiv = sel.value;
        }
      });
    });
    header.querySelectorAll('button[data-ctrl]').forEach(btn => {
      btn.addEventListener('click', e => {
        e.stopPropagation();
        const ctrl = btn.dataset.ctrl;
        const idx = +btn.dataset.seq;
        const sq = sequencers[idx];
        if (ctrl === 'mute') {
          sq.muted = !sq.muted;
        } else if (ctrl === 'solo') {
          sq.solo = !sq.solo;
        } else if (ctrl === 'rotL') {
          sq.trigger.rotation = (sq.trigger.rotation + 1 + sq.trigger.steps) % sq.trigger.steps;
          const newP = seqEuclidean(sq.trigger.steps, sq.trigger.hits, sq.trigger.rotation);
          for (let i = 0; i < sq.trigger.steps; i++) if (!sq.trigger.overrides.has(i)) sq.trigger.pattern[i] = newP[i];
        } else if (ctrl === 'rotR') {
          sq.trigger.rotation = (sq.trigger.rotation - 1 + sq.trigger.steps) % sq.trigger.steps;
          const newP = seqEuclidean(sq.trigger.steps, sq.trigger.hits, sq.trigger.rotation);
          for (let i = 0; i < sq.trigger.steps; i++) if (!sq.trigger.overrides.has(i)) sq.trigger.pattern[i] = newP[i];
        }
        seqRenderOverview();
      });
    });

    // Grid body
    const gridWrap = document.createElement('div');
    gridWrap.className = 'seq-ov-grid-wrap';
    const grid = document.createElement('div');
    grid.className = 'seq-step-grid';
    grid.id = 'seqOvGrid' + si;

    for (let i = 0; i < 16; i++) {
      const inRange = i < s.trigger.steps;
      const active = inRange && s.trigger.pattern[i];
      const ratch = s.trigger.ratchet[i] ?? 1;
      const prob = s.trigger.probability[i] ?? 1.0;
      const probPct = Math.round(prob * 100);
      const step = document.createElement('div');
      step.className = 'seq-step';

      const showNum = (i % 4 === 0);
      const numLabel = showNum ? (i + 1) : '';
      const cellCls = 'seq-step-cell' + (active ? ' active' : '') + (!inRange ? ' inactive' : '');

      let ratchHtml = '';
      for (let r = 0; r < ratch; r++) ratchHtml += '<span class="ratch-line"></span>';
      const ratchCls = 'seq-step-ratchet' + (ratch > 1 ? ' multi r' + ratch : '');

      step.innerHTML =
        '<div class="seq-step-num">' + numLabel + '</div>' +
        '<div class="' + cellCls + '" data-step="' + i + '" data-seq="' + si + '" style="touch-action:none">' +
          '<div class="prob-fill" style="height:' + (prob * 100) + '%"></div>' +
          '<div class="prob-label">' + probPct + '%</div>' +
        '</div>' +
        '<div class="' + ratchCls + '" data-step="' + i + '" data-seq="' + si + '" style="' + (!inRange ? 'opacity:0.25' : '') + '">' +
          ratchHtml +
        '</div>';

      if (inRange) {
        const cell = step.querySelector('.seq-step-cell');
        cell.addEventListener('pointerdown', (e) => seqOvStepPointerDown(e, si, i));
        cell.addEventListener('dblclick', () => seqOvStepDblClick(si, i));
        step.querySelector('.seq-step-ratchet').addEventListener('click', () => seqOvCycleRatchet(si, i));
      }
      grid.appendChild(step);
    }
    gridWrap.appendChild(grid);
    row.appendChild(gridWrap);
    c.appendChild(row);
  });
}

// ── Overview step interactions ──
function seqOvStepPointerDown(e, seqIdx, stepIdx) {
  const s = sequencers[seqIdx];
  if (stepIdx >= s.trigger.steps) return;
  if (e.button !== 0) return;
  e.preventDefault();
  const cell = e.currentTarget;
  const startY = e.clientY;
  let dragged = false;
  const pid = e.pointerId;
  cell.setPointerCapture(pid);

  const onMove = (ev) => {
    if (Math.abs(ev.clientY - startY) > 5) dragged = true;
    if (!dragged) return;
    const dy = startY - ev.clientY;
    let newProb = Math.max(0, Math.min(1, 0.5 + dy / 120));
    newProb = Math.round(newProb * 20) / 20;
    s.trigger.probability[stepIdx] = newProb;
    const fill = cell.querySelector('.prob-fill');
    const lbl = cell.querySelector('.prob-label');
    if (fill) fill.style.height = (newProb * 100) + '%';
    if (lbl) lbl.textContent = Math.round(newProb * 100) + '%';
    seqShowDragPopup(ev.clientX, ev.clientY, Math.round(newProb * 100) + '%');
  };
  const onUp = () => {
    cell.removeEventListener('pointermove', onMove);
    cell.removeEventListener('pointerup', onUp);
    cell.removeEventListener('pointercancel', onUp);
    seqHideDragPopup();
    if (!dragged) {
      s.trigger.pattern[stepIdx] = !s.trigger.pattern[stepIdx];
      if (s.trigger.pattern[stepIdx]) s.trigger.overrides.add(stepIdx);
      else s.trigger.overrides.delete(stepIdx);
      seqSyncLinkedSteps(s);
      seqRenderOverview();
    }
  };
  cell.addEventListener('pointermove', onMove);
  cell.addEventListener('pointerup', onUp);
  cell.addEventListener('pointercancel', onUp);
}

function seqOvStepDblClick(seqIdx, stepIdx) {
  const s = sequencers[seqIdx];
  s.trigger.probability[stepIdx] = 1.0;
  s.trigger.ratchet[stepIdx] = 1;
  const baseP = seqEuclidean(s.trigger.steps, s.trigger.hits, s.trigger.rotation);
  s.trigger.pattern[stepIdx] = baseP[stepIdx];
  s.trigger.overrides.delete(stepIdx);
  seqSyncLinkedSteps(s);
  seqRenderOverview();
}

function seqOvCycleRatchet(seqIdx, stepIdx) {
  const s = sequencers[seqIdx];
  const cur = s.trigger.ratchet[stepIdx] ?? 1;
  s.trigger.ratchet[stepIdx] = cur >= 4 ? 1 : cur + 1;
  seqRenderOverview();
}

// ── Mini Overview (all 4 sequencers) ──
function seqRenderMiniOverview() {
  const c = document.getElementById('seqMiniOverview');
  c.innerHTML = '';
  sequencers.forEach((s, i) => {
    const row = document.createElement('div');
    row.className = 'seq-mini-row' + (i === seqActiveTab ? ' active' : '') + (s.muted ? ' muted' : '');
    row.dataset.seq = i;
    row.style.setProperty('--sc', s.color);
    row.onclick = () => seqSwitchTab(i);

    const mState = s.muted ? '<span class="on">M</span>' : 'M';
    const sState = s.solo ? '<span class="on">S</span>' : 'S';
    const src = getSeqActiveSources(s);
    const srcBrief = src.length === 0 ? '\u2014' : src.length <= 2 ? src.join('+') : src.length + 'v';

    let dots = '';
    for (let j = 0; j < s.trigger.steps; j++) {
      const hit = s.trigger.pattern[j];
      const isCur = seqPlaying && j === s.lastDisplayStep;
      dots += '<span class="' + (hit ? 'dot-hit' : 'dot-rest') + (isCur ? ' dot-cur' : '') + '">' + (hit ? '\u25cf' : '\u25cb') + '</span>';
    }

    row.innerHTML =
      '<div class="seq-mini-label"><span>' + s.name + ' (' + s.clockDiv + ') ' + srcBrief + '</span><span class="mini-ms">' + mState + ' ' + sState + '</span></div>' +
      '<div class="seq-mini-dots">' + dots + '</div>';
    c.appendChild(row);
  });
}

// ── Init ──
function seqInit() {
  seqRenderTabBar();
  seqRenderBody();
  seqRenderMiniOverview();

  // Bind BPM drag-number
  seqDragNumBind(document.getElementById('seqBpm'), {
    min: 40, max: () => 300, label: 'BPM: ',
    get: () => seqGlobalBpm,
    set: (v) => { seqGlobalBpm = v; }
  });
}

seqInit();

console.log('Kessho Drum Synth UI — 4-Seq Super Sequencer + keyboard (A S D F G H J K / Space). State:', state, sequencers);
</script>
</body>
</html>
